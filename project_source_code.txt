====================================================================
### Plik: ./frontend/Dockerfile
====================================================================
# --- Etap 1: Budowanie Aplikacji React ---
    FROM node:18-alpine AS builder

    WORKDIR /app
    
    # Kopiujemy package.json i package-lock.json (lub yarn.lock)
    COPY package*.json ./
    
    # Instalujemy zależności
    RUN npm install
    
    # Kopiujemy resztę kodu źródłowego aplikacji
    COPY . .
    
    # Budujemy aplikację w wersji produkcyjnej
    # Folder /app/build będzie zawierał gotowe, statyczne pliki
    RUN npm run build
    
    
    # --- Etap 2: Serwowanie plików przez Nginx ---
    FROM nginx:1.25-alpine
    
    # Usuwamy domyślną konfigurację Nginx
    RUN rm /etc/nginx/conf.d/default.conf
    
    # Kopiujemy naszą własną konfigurację Nginx
    COPY nginx/default.conf /etc/nginx/conf.d/default.conf
    
    # Kopiujemy zbudowane pliki statyczne z etapu "builder"
    # do katalogu, z którego Nginx serwuje pliki
    COPY --from=builder /app/build /usr/share/nginx/html
    
    # Uruchamiamy Nginx na pierwszym planie
    CMD ["nginx", "-g", "daemon off;"]
====================================================================
### Plik: ./frontend/public/index.html
====================================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

====================================================================
### Plik: ./frontend/public/manifest.json
====================================================================
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

====================================================================
### Plik: ./frontend/package.json
====================================================================
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@date-io/date-fns": "^3.0.0",
    "@emotion/react": "^11.11.4",
    "@emotion/styled": "^11.11.5",
    "@fontsource/inter": "^5.0.18",
    "@mui/icons-material": "^5.15.19",
    "@mui/lab": "^5.0.0-alpha.170",
    "@mui/material": "^5.15.19",
    "@mui/x-data-grid": "^7.6.2",
    "@mui/x-date-pickers": "^7.6.2",
    "@tanstack/react-query": "^5.45.1",
    "axios": "^1.7.2",
    "date-fns": "^3.6.0",
    "react": "^18.3.1",
    "react-big-calendar": "^1.12.2",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.23.1",
    "react-scripts": "5.0.1",
    "web-vitals": "^4.0.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

====================================================================
### Plik: ./frontend/nginx/default.conf
====================================================================
server {
    listen 80;
    server_name localhost;

    # Lokalizacja dla plików statycznych aplikacji React
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
        # Kluczowe dla Single Page Application:
        # Jeśli plik lub katalog nie istnieje, zwróć index.html
        try_files $uri $uri/ /index.html;
    }

    # POPRAWKA: Nowa, poprawna konfiguracja proxy dla API
    # Ta metoda jest standardowa i bardziej niezawodna niż używanie `rewrite`.
    location /api/ {
        # Usuwa /api/ z początku ścieżki i przekazuje resztę do backendu.
        # Np. zapytanie na /api/users/ zostanie przekazane jako /users/ do backendu.
        proxy_pass http://backend:8000/;

        # Ustawiamy nagłówki, aby przekazać oryginalne informacje do backendu
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
====================================================================
### Plik: ./frontend/src/contexts/AuthContext.js
====================================================================
import React, { createContext, useState, useEffect, useCallback } from "react";
import {
  getCurrentUser,
  login as apiLogin,
  logout as apiLogout,
  isAuthenticated,
} from "../api/authService";

export const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const checkAuthState = useCallback(async () => {
    if (isAuthenticated()) {
      try {
        const userData = await getCurrentUser();
        setUser(userData);
      } catch (error) {
        console.error("Auth check failed, logging out.", error);
        apiLogout();
        setUser(null);
      }
    }
    setLoading(false);
  }, []);

  useEffect(() => {
    checkAuthState();
  }, [checkAuthState]);

  const login = async (email, password) => {
    await apiLogin(email, password);
    const userData = await getCurrentUser();
    setUser(userData);
  };

  const logout = () => {
    apiLogout();
    setUser(null);
  };

  const value = {
    user,
    isAuthenticated: !!user,
    loading,
    login,
    logout,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

====================================================================
### Plik: ./frontend/src/features/Calendar/ChangeRequestDialog.js
====================================================================
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Button,
  Stack,
  Alert,
} from "@mui/material";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "../../api/apiService";

const ChangeRequestDialog = ({ event, open, onClose }) => {
  const queryClient = useQueryClient();
  const [formData, setFormData] = useState({
    reason: "",
    room_requirements: "",
    minimum_capacity: "",
  });

  useEffect(() => {
    if (open) {
      setFormData({ reason: "", room_requirements: "", minimum_capacity: "" });
    }
  }, [open]);

  const mutation = useMutation({
    mutationFn: (newRequest) =>
      apiRequest("/change-requests/", {
        method: "POST",
        body: JSON.stringify(newRequest),
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["change-requests"] });
      queryClient.invalidateQueries({ queryKey: ["related-requests"] });
      onClose();
    },
  });

  const handleChange = (e) => {
    setFormData((prev) => ({ ...prev, [e.target.name]: e.target.value }));
  };

  const handleSubmit = () => {
    if (!event) return;
    mutation.mutate({
      course_event_id: event.id.split("-")[1],
      reason: formData.reason,
      room_requirements: formData.room_requirements,
      minimum_capacity: parseInt(formData.minimum_capacity, 10) || 0,
    });
  };

  return (
    <Dialog open={open} onClose={onClose} fullWidth maxWidth="sm">
      <DialogTitle>Zgłoś potrzebę zmiany</DialogTitle>
      <DialogContent>
        <Stack spacing={2} sx={{ mt: 2 }}>
          {mutation.isError && (
            <Alert severity="error">{mutation.error.message}</Alert>
          )}
          <TextField
            margin="dense"
            label="Powód zmiany"
            name="reason"
            fullWidth
            multiline
            rows={3}
            value={formData.reason}
            onChange={handleChange}
            required
            disabled={mutation.isPending}
          />
          <TextField
            margin="dense"
            label="Wymagania dotyczące sali (np. Rzutnik, Tablica)"
            name="room_requirements"
            fullWidth
            value={formData.room_requirements}
            onChange={handleChange}
            disabled={mutation.isPending}
          />
          <TextField
            margin="dense"
            label="Minimalna pojemność sali"
            name="minimum_capacity"
            fullWidth
            type="number"
            value={formData.minimum_capacity}
            onChange={handleChange}
            disabled={mutation.isPending}
          />
        </Stack>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose} disabled={mutation.isPending}>
          Anuluj
        </Button>
        <Button
          onClick={handleSubmit}
          variant="contained"
          disabled={mutation.isPending}
        >
          {mutation.isPending ? "Wysyłanie..." : "Wyślij zgłoszenie"}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default ChangeRequestDialog;

====================================================================
### Plik: ./frontend/src/features/Calendar/EventDialog.js
====================================================================
import React from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  List,
  ListItem,
  ListItemText,
  Button,
  CircularProgress,
  Typography,
  Chip,
} from "@mui/material";
import { useQuery } from "@tanstack/react-query";
import { apiRequest } from "../../api/apiService";

const EventDialog = ({ event, open, onClose, onProposeChange }) => {
  const { data: room, isLoading: isLoadingRoom } = useQuery({
    queryKey: ["rooms", event?.room_id],
    queryFn: () => apiRequest(`/rooms/${event.room_id}`),
    enabled: !!event?.room_id,
  });

  return (
    <Dialog open={open} onClose={onClose} fullWidth maxWidth="xs">
      <DialogTitle>Szczegóły wydarzenia</DialogTitle>
      <DialogContent dividers>
        {event ? (
          <List>
            <ListItem>
              <ListItemText primary="Kurs" secondary={event.title} />
            </ListItem>
            <ListItem>
              <ListItemText
                primary="Data"
                secondary={event.start.toLocaleDateString("pl-PL")}
              />
            </ListItem>
            <ListItem>
              <ListItemText
                primary="Godziny"
                secondary={`${event.start.toLocaleTimeString("pl-PL", {
                  hour: "2-digit",
                  minute: "2-digit",
                })} - ${event.end.toLocaleTimeString("pl-PL", {
                  hour: "2-digit",
                  minute: "2-digit",
                })}`}
              />
            </ListItem>
            <ListItem>
              <ListItemText
                primary="Sala"
                secondary={
                  isLoadingRoom ? (
                    <CircularProgress size={20} />
                  ) : (
                    room?.name || "Brak przypisanej sali"
                  )
                }
              />
            </ListItem>
            {room && (
              <>
                <ListItem>
                  <ListItemText
                    primary="Pojemność sali"
                    secondary={room.capacity}
                  />
                </ListItem>
                <ListItem>
                  <Typography variant="subtitle2" sx={{ pl: 2, pt: 1 }}>
                    Wyposażenie
                  </Typography>
                </ListItem>
                <ListItem sx={{ display: "flex", flexWrap: "wrap", gap: 1 }}>
                  {room.equipment.length > 0 ? (
                    room.equipment.map((eq) => (
                      <Chip key={eq.id} label={eq.name} size="small" />
                    ))
                  ) : (
                    <Typography variant="body2" color="text.secondary">
                      Brak
                    </Typography>
                  )}
                </ListItem>
              </>
            )}
          </List>
        ) : (
          <CircularProgress />
        )}
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>Zamknij</Button>
        <Button onClick={onProposeChange} variant="contained" disabled={!event}>
          Zgłoś potrzebę zmiany
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default EventDialog;

====================================================================
### Plik: ./frontend/src/features/Admin/AdminDataGrid.js
====================================================================
import React, { useState } from "react";
import {
  Box,
  Paper,
  Toolbar,
  TextField,
  Button,
  CircularProgress,
  Alert,
} from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import AddIcon from "@mui/icons-material/Add";

const AdminDataGrid = ({
  columns,
  rows,
  isLoading,
  isError,
  error,
  onAddItem,
  toolbarConfig,
}) => {
  const [searchText, setSearchText] = useState("");

  const filteredRows = rows.filter((row) => {
    if (!searchText) return true;
    return Object.values(row).some((value) =>
      String(value).toLowerCase().includes(searchText.toLowerCase())
    );
  });

  return (
    <Paper>
      <Toolbar>
        <Box sx={{ flexGrow: 1 }}>
          <TextField
            variant="outlined"
            size="small"
            placeholder={toolbarConfig.searchPlaceholder || "Szukaj..."}
            value={searchText}
            onChange={(e) => setSearchText(e.target.value)}
            sx={{ width: { xs: "100%", sm: 350 } }}
          />
        </Box>
        <Button variant="contained" startIcon={<AddIcon />} onClick={onAddItem}>
          {toolbarConfig.addLabel || "Dodaj"}
        </Button>
      </Toolbar>
      {isError && <Alert severity="error">Błąd: {error?.message}</Alert>}
      <Box sx={{ height: "70vh", width: "100%" }}>
        <DataGrid
          rows={filteredRows}
          columns={columns}
          loading={isLoading}
          getRowId={(row) => row.id}
          pageSizeOptions={[10, 25, 50]}
          checkboxSelection
          disableRowSelectionOnClick
          slots={{
            loadingOverlay: () => (
              <Box
                sx={{
                  height: "100%",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                }}
              >
                <CircularProgress />
              </Box>
            ),
          }}
        />
      </Box>
    </Paper>
  );
};

export default AdminDataGrid;

====================================================================
### Plik: ./frontend/src/features/Admin/UserFormDialog.js
====================================================================
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Button,
  Stack,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
} from "@mui/material";

const UserFormDialog = ({ open, onClose, onSave, user }) => {
  const [formData, setFormData] = useState({
    name: "",
    surname: "",
    email: "",
    password: "",
    role: "PROWADZACY",
  });
  const [error, setError] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    if (user) {
      setFormData({
        name: user.name || "",
        surname: user.surname || "",
        email: user.email || "",
        password: "",
        role: user.role || "PROWADZACY",
      });
    } else {
      setFormData({
        name: "",
        surname: "",
        email: "",
        password: "",
        role: "PROWADZACY",
      });
    }
    setError("");
  }, [user, open]);

  const handleChange = (e) => {
    setFormData((prev) => ({ ...prev, [e.target.name]: e.target.value }));
  };

  const handleSubmit = async () => {
    setError("");
    setIsSubmitting(true);
    const result = await onSave(formData);
    setIsSubmitting(false);
    if (result instanceof Error) {
      setError(result.message);
    } else {
      onClose();
    }
  };

  const editMode = !!user;

  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>
        {editMode ? "Edytuj użytkownika" : "Dodaj nowego użytkownika"}
      </DialogTitle>
      <DialogContent>
        <Stack spacing={2} sx={{ mt: 2 }}>
          {error && <Alert severity="error">{error}</Alert>}
          <TextField
            label="Imię"
            name="name"
            fullWidth
            value={formData.name}
            onChange={handleChange}
            required
          />
          <TextField
            label="Nazwisko"
            name="surname"
            fullWidth
            value={formData.surname}
            onChange={handleChange}
            required
          />
          <TextField
            label="Adres Email"
            name="email"
            type="email"
            fullWidth
            value={formData.email}
            onChange={handleChange}
            required
          />
          <TextField
            label="Hasło"
            name="password"
            type="password"
            fullWidth
            value={formData.password}
            onChange={handleChange}
            required={!editMode}
            helperText={
              editMode ? "Pozostaw puste, aby nie zmieniać hasła" : ""
            }
          />
          <FormControl fullWidth>
            <InputLabel>Rola</InputLabel>
            <Select
              name="role"
              value={formData.role}
              label="Rola"
              onChange={handleChange}
            >
              <MenuItem value="PROWADZACY">Prowadzący</MenuItem>
              <MenuItem value="STAROSTA">Starosta</MenuItem>
              <MenuItem value="KOORDYNATOR">Koordynator</MenuItem>
              <MenuItem value="ADMIN">Administrator</MenuItem>
            </Select>
          </FormControl>
        </Stack>
      </DialogContent>
      <DialogActions sx={{ p: "16px 24px" }}>
        <Button onClick={onClose} disabled={isSubmitting}>
          Anuluj
        </Button>
        <Button
          onClick={handleSubmit}
          variant="contained"
          disabled={isSubmitting}
        >
          {isSubmitting
            ? "Zapisywanie..."
            : editMode
            ? "Zapisz zmiany"
            : "Dodaj"}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default UserFormDialog;

====================================================================
### Plik: ./frontend/src/features/Admin/CourseFormDialog.js
====================================================================
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Button,
  Stack,
  MenuItem,
  Alert,
} from "@mui/material";
import { useQuery } from "@tanstack/react-query";
import { apiRequest } from "../../api/apiService";

const useTeachers = () =>
  useQuery({
    queryKey: ["users", { role: "PROWADZACY" }],
    queryFn: async () => {
      const users = await apiRequest("/users");
      return users.filter((user) => user.role === "PROWADZACY");
    },
  });
const useGroups = () =>
  useQuery({ queryKey: ["groups"], queryFn: () => apiRequest("/groups") });

const CourseFormDialog = ({ open, onClose, onSave, course }) => {
  const { data: teachers = [], isLoading: isLoadingTeachers } = useTeachers();
  const { data: groups = [], isLoading: isLoadingGroups } = useGroups();
  const [formData, setFormData] = useState({
    name: "",
    teacher_id: "",
    group_id: "",
  });
  const [error, setError] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    if (course) {
      setFormData({
        name: course.name || "",
        teacher_id: course.teacher_id || "",
        group_id: course.group_id || "",
      });
    } else {
      setFormData({ name: "", teacher_id: "", group_id: "" });
    }
    setError("");
  }, [course, open]);

  const handleChange = (e) => {
    setFormData((prev) => ({ ...prev, [e.target.name]: e.target.value }));
  };

  const handleSubmit = async () => {
    setError("");
    setIsSubmitting(true);
    const result = await onSave(formData);
    setIsSubmitting(false);
    if (result instanceof Error) {
      setError(result.message);
    } else {
      onClose();
    }
  };

  const editMode = !!course;

  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>{editMode ? "Edytuj kurs" : "Dodaj nowy kurs"}</DialogTitle>
      <DialogContent>
        <Stack spacing={2} sx={{ mt: 2 }}>
          {error && <Alert severity="error">{error}</Alert>}
          <TextField
            label="Nazwa kursu"
            name="name"
            fullWidth
            value={formData.name}
            onChange={handleChange}
            required
          />
          <TextField
            select
            label="Prowadzący"
            name="teacher_id"
            fullWidth
            value={formData.teacher_id}
            onChange={handleChange}
            required
            disabled={isLoadingTeachers}
          >
            {teachers.map((teacher) => (
              <MenuItem key={teacher.id} value={teacher.id}>
                {teacher.name} {teacher.surname}
              </MenuItem>
            ))}
          </TextField>
          <TextField
            select
            label="Grupa"
            name="group_id"
            fullWidth
            value={formData.group_id}
            onChange={handleChange}
            required
            disabled={isLoadingGroups}
          >
            {groups.map((group) => (
              <MenuItem key={group.id} value={group.id}>
                {group.name}
              </MenuItem>
            ))}
          </TextField>
        </Stack>
      </DialogContent>
      <DialogActions sx={{ p: "16px 24px" }}>
        <Button onClick={onClose} disabled={isSubmitting}>
          Anuluj
        </Button>
        <Button
          onClick={handleSubmit}
          variant="contained"
          disabled={isSubmitting}
        >
          {isSubmitting ? "Zapisywanie..." : "Dodaj"}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default CourseFormDialog;

====================================================================
### Plik: ./frontend/src/features/Admin/GroupFormDialog.js
====================================================================
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Button,
  Stack,
  MenuItem,
  Alert,
} from "@mui/material";
import { useQuery } from "@tanstack/react-query";
import { apiRequest } from "../../api/apiService";

const useLeaders = () => {
  return useQuery({
    queryKey: ["users", { role: "STAROSTA" }],
    queryFn: async () => {
      const users = await apiRequest("/users");
      return users.filter((user) => user.role === "STAROSTA");
    },
  });
};

const GroupFormDialog = ({ open, onClose, onSave, group }) => {
  const { data: leaders = [], isLoading: isLoadingLeaders } = useLeaders();
  const [formData, setFormData] = useState({
    name: "",
    year: "",
    leader_id: "",
  });
  const [error, setError] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    if (group) {
      setFormData({
        name: group.name || "",
        year: group.year || "",
        leader_id: group.leader_id || "",
      });
    } else {
      setFormData({ name: "", year: "", leader_id: "" });
    }
    setError("");
  }, [group, open]);

  const handleChange = (e) => {
    setFormData((prev) => ({ ...prev, [e.target.name]: e.target.value }));
  };

  const handleSubmit = async () => {
    setError("");
    setIsSubmitting(true);
    const payload = {
      ...formData,
      year: parseInt(formData.year, 10) || null,
      leader_id: parseInt(formData.leader_id, 10) || null,
    };
    const result = await onSave(payload);
    setIsSubmitting(false);
    if (result instanceof Error) {
      setError(result.message);
    } else {
      onClose();
    }
  };

  const editMode = !!group;

  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>
        {editMode ? "Edytuj grupę" : "Dodaj nową grupę"}
      </DialogTitle>
      <DialogContent>
        <Stack spacing={2} sx={{ mt: 2 }}>
          {error && <Alert severity="error">{error}</Alert>}
          <TextField
            label="Nazwa grupy"
            name="name"
            fullWidth
            value={formData.name}
            onChange={handleChange}
            required
          />
          <TextField
            label="Rok studiów"
            name="year"
            type="number"
            fullWidth
            value={formData.year}
            onChange={handleChange}
            required
          />
          <TextField
            select
            label="Starosta"
            name="leader_id"
            fullWidth
            value={formData.leader_id}
            onChange={handleChange}
            required
            disabled={isLoadingLeaders}
          >
            {leaders.map((leader) => (
              <MenuItem key={leader.id} value={leader.id}>
                {leader.name} {leader.surname}
              </MenuItem>
            ))}
          </TextField>
        </Stack>
      </DialogContent>
      <DialogActions sx={{ p: "16px 24px" }}>
        <Button onClick={onClose} disabled={isSubmitting}>
          Anuluj
        </Button>
        <Button
          onClick={handleSubmit}
          variant="contained"
          disabled={isSubmitting}
        >
          {isSubmitting
            ? "Zapisywanie..."
            : editMode
            ? "Zapisz zmiany"
            : "Dodaj"}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default GroupFormDialog;

====================================================================
### Plik: ./frontend/src/features/Admin/RoomFormDialog.js
====================================================================
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Button,
  Stack,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  Checkbox,
  ListItemText,
  OutlinedInput,
} from "@mui/material";
import { useQuery } from "@tanstack/react-query";
import { apiRequest } from "../../api/apiService";

const roomTypeTranslations = {
  LECTURE_HALL: "Sala wykładowa",
  LABORATORY: "Laboratorium",
  SEMINAR_ROOM: "Sala seminaryjna",
  CONFERENCE_ROOM: "Sala konferencyjna",
  OTHER: "Inne",
};

const useEquipment = () => {
  return useQuery({
    queryKey: ["equipment"],
    queryFn: () => apiRequest("/equipment"),
  });
};

const RoomFormDialog = ({ open, onClose, onSave, room }) => {
  const { data: allEquipment = [], isLoading: isLoadingEquipment } =
    useEquipment();
  const [formData, setFormData] = useState({
    name: "",
    capacity: "",
    type: "LECTURE_HALL",
    equipment_ids: [],
  });
  const [error, setError] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    if (room) {
      setFormData({
        name: room.name || "",
        capacity: room.capacity || "",
        type: room.type || "LECTURE_HALL",
        equipment_ids: room.equipment?.map((eq) => eq.id) || [],
      });
    } else {
      setFormData({
        name: "",
        capacity: "",
        type: "LECTURE_HALL",
        equipment_ids: [],
      });
    }
    setError("");
  }, [room, open]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  };

  const handleEquipmentChange = (event) => {
    const {
      target: { value },
    } = event;
    setFormData((prev) => ({
      ...prev,
      equipment_ids: typeof value === "string" ? value.split(",") : value,
    }));
  };

  const handleSubmit = async () => {
    setError("");
    setIsSubmitting(true);
    const payload = {
      ...formData,
      capacity: parseInt(formData.capacity, 10) || 0,
    };
    const result = await onSave(payload);
    setIsSubmitting(false);
    if (result instanceof Error) {
      setError(result.message);
    } else {
      onClose();
    }
  };

  const editMode = !!room;
  const equipmentNameMap = new Map(allEquipment.map((eq) => [eq.id, eq.name]));

  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>{editMode ? "Edytuj salę" : "Dodaj nową salę"}</DialogTitle>
      <DialogContent>
        <Stack spacing={2} sx={{ mt: 2 }}>
          {error && <Alert severity="error">{error}</Alert>}
          <TextField
            label="Nazwa"
            name="name"
            fullWidth
            value={formData.name}
            onChange={handleChange}
            required
          />
          <TextField
            label="Pojemność"
            name="capacity"
            type="number"
            fullWidth
            value={formData.capacity}
            onChange={handleChange}
            required
          />
          <FormControl fullWidth>
            <InputLabel>Typ Sali</InputLabel>
            <Select
              name="type"
              value={formData.type}
              label="Typ Sali"
              onChange={handleChange}
            >
              {Object.entries(roomTypeTranslations).map(([key, value]) => (
                <MenuItem key={key} value={key}>
                  {value}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
          <FormControl fullWidth>
            <InputLabel>Wyposażenie</InputLabel>
            <Select
              multiple
              name="equipment_ids"
              value={formData.equipment_ids}
              onChange={handleEquipmentChange}
              input={<OutlinedInput label="Wyposażenie" />}
              renderValue={(selected) =>
                selected.map((id) => equipmentNameMap.get(id)).join(", ")
              }
              disabled={isLoadingEquipment}
            >
              {allEquipment.map((eq) => (
                <MenuItem key={eq.id} value={eq.id}>
                  <Checkbox
                    checked={formData.equipment_ids.indexOf(eq.id) > -1}
                  />
                  <ListItemText primary={eq.name} />
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Stack>
      </DialogContent>
      <DialogActions sx={{ p: "16px 24px" }}>
        <Button onClick={onClose} disabled={isSubmitting}>
          Anuluj
        </Button>
        <Button
          onClick={handleSubmit}
          variant="contained"
          disabled={isSubmitting}
        >
          {isSubmitting
            ? "Zapisywanie..."
            : editMode
            ? "Zapisz zmiany"
            : "Dodaj"}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default RoomFormDialog;

====================================================================
### Plik: ./frontend/src/features/Proposals/AvailabilitySelector.js
====================================================================
import React, { useState, useMemo } from "react";
import {
  Box,
  Typography,
  Paper,
  Grid,
  Chip,
  CircularProgress,
  Alert,
} from "@mui/material";
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "../../api/apiService";
import { format } from "date-fns";

const timeSlotMap = {
  1: "08:00-09:30",
  2: "09:45-11:15",
  3: "11:30-13:00",
  4: "13:15-14:45",
  5: "15:00-16:30",
  6: "16:45-18:15",
  7: "18:30-20:00",
};

const AvailabilitySelector = ({ changeRequestId, onProposalChange }) => {
  const queryClient = useQueryClient();
  const [selectedDate, setSelectedDate] = useState(new Date());

  const { data: proposals = [], isLoading: isLoadingProposals } = useQuery({
    queryKey: ["proposals", changeRequestId],
    queryFn: () =>
      apiRequest(`/proposals?change_request_id=${changeRequestId}`),
    enabled: !!changeRequestId,
  });

  const mutationOptions = {
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: ["proposals", changeRequestId],
      });
      if (onProposalChange) {
        onProposalChange();
      }
    },
  };

  const createMutation = useMutation({
    mutationFn: (newProposal) =>
      apiRequest("/proposals/", {
        method: "POST",
        body: JSON.stringify(newProposal),
      }),
    ...mutationOptions,
  });

  const deleteMutation = useMutation({
    mutationFn: (proposalId) =>
      apiRequest(`/proposals/${proposalId}`, { method: "DELETE" }),
    ...mutationOptions,
  });

  const handleSlotClick = (slotId) => {
    const formattedDate = format(selectedDate, "yyyy-MM-dd");
    const existingProposal = proposals.find(
      (p) =>
        format(new Date(p.day), "yyyy-MM-dd") === formattedDate &&
        p.time_slot_id === slotId
    );

    if (existingProposal) {
      deleteMutation.mutate(existingProposal.id);
    } else {
      createMutation.mutate({
        change_request_id: changeRequestId,
        day: formattedDate,
        time_slot_id: slotId,
      });
    }
  };

  return (
    <Paper sx={{ p: 2, display: "flex", flexDirection: "column", gap: 2 }}>
      <Typography variant="h6">Zaproponuj swoją dostępność</Typography>
      <DatePicker
        label="Wybierz dzień"
        value={selectedDate}
        onChange={(newValue) => setSelectedDate(newValue)}
        disablePast
      />

      {isLoadingProposals ? (
        <CircularProgress />
      ) : (
        <Grid container spacing={1}>
          {Object.entries(timeSlotMap).map(([id, time]) => {
            const slotId = parseInt(id, 10);
            const formattedDate = format(selectedDate, "yyyy-MM-dd");
            const isProposed = proposals.some(
              (p) =>
                format(new Date(p.day), "yyyy-MM-dd") === formattedDate &&
                p.time_slot_id === slotId
            );
            const isMutating =
              (createMutation.isPending &&
                createMutation.variables?.time_slot_id === slotId) ||
              (deleteMutation.isPending &&
                proposals.find((p) => p.id === deleteMutation.variables)
                  ?.time_slot_id === slotId);

            return (
              <Grid item xs={6} sm={4} key={id}>
                <Chip
                  label={time}
                  clickable
                  onClick={() => handleSlotClick(slotId)}
                  color={isProposed ? "success" : "default"}
                  variant={isProposed ? "filled" : "outlined"}
                  sx={{ width: "100%", fontWeight: 600 }}
                  disabled={isMutating}
                  icon={isMutating ? <CircularProgress size={16} /> : null}
                />
              </Grid>
            );
          })}
        </Grid>
      )}

      {createMutation.isError && (
        <Alert severity="error">{createMutation.error.message}</Alert>
      )}
      {deleteMutation.isError && (
        <Alert severity="error">{deleteMutation.error.message}</Alert>
      )}
    </Paper>
  );
};

export default AvailabilitySelector;

====================================================================
### Plik: ./frontend/src/index.js
====================================================================
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

====================================================================
### Plik: ./frontend/src/index.css
====================================================================
body {
  margin: 0;
  font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto",
    "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  padding: 0;
  box-sizing: border-box;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, "Courier New",
    monospace;
}

====================================================================
### Plik: ./frontend/src/components/layout/PublicRoute.js
====================================================================
import React, { useContext } from "react";
import { Navigate, Outlet } from "react-router-dom";
import { AuthContext } from "../../contexts/AuthContext";

const PublicRoute = () => {
  const { isAuthenticated } = useContext(AuthContext);

  if (isAuthenticated) {
    return <Navigate to="/" replace />;
  }

  return <Outlet />;
};

export default PublicRoute;

====================================================================
### Plik: ./frontend/src/components/layout/Sidebar.js
====================================================================
import React, { useContext } from "react";
import {
  Box,
  Drawer,
  Typography,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Avatar,
  Divider,
} from "@mui/material";
import { NavLink } from "react-router-dom";
import { AuthContext } from "../../contexts/AuthContext";

import DashboardIcon from "@mui/icons-material/Dashboard";
import MeetingRoomIcon from "@mui/icons-material/MeetingRoom";
import EventNoteIcon from "@mui/icons-material/EventNote";
import PeopleIcon from "@mui/icons-material/People";
import GroupsIcon from "@mui/icons-material/Groups";
import SchoolIcon from "@mui/icons-material/School";
import RecommendIcon from "@mui/icons-material/Recommend";

const drawerWidth = 280;

const getInitials = (name) => {
  if (!name) return "";
  const parts = name.split(" ");
  if (parts.length > 1 && parts[1]) {
    return `${parts[0][0]}${parts[1][0]}`.toUpperCase();
  }
  return name.substring(0, 2).toUpperCase();
};

const roleTranslations = {
  ADMIN: "Administrator",
  KOORDYNATOR: "Koordynator",
  PROWADZACY: "Prowadzący",
  STAROSTA: "Starosta",
};

const commonNavItems = [
  { text: "Dashboard", icon: <DashboardIcon />, path: "/" },
  { text: "Kalendarz", icon: <EventNoteIcon />, path: "/calendar" },
  { text: "Rekomendacje", icon: <RecommendIcon />, path: "/recommendations" },
];

const adminNavItems = [
  { text: "Użytkownicy", icon: <PeopleIcon />, path: "/users" },
  { text: "Grupy", icon: <GroupsIcon />, path: "/groups" },
  { text: "Sale", icon: <MeetingRoomIcon />, path: "/rooms" },
  { text: "Kursy", icon: <SchoolIcon />, path: "/courses" },
];

const Sidebar = () => {
  const { user } = useContext(AuthContext);

  const getNavItems = () => {
    switch (user?.role) {
      case "ADMIN":
        return [...commonNavItems, ...adminNavItems];
      case "KOORDYNATOR":
        return [...commonNavItems, ...adminNavItems.slice(1)];
      case "PROWADZACY":
      case "STAROSTA":
        return commonNavItems;
      default:
        return [];
    }
  };

  const navItems = getNavItems();

  const drawerContent = (
    <div>
      <Box sx={{ p: 2.5, display: "flex", alignItems: "center", gap: 2 }}>
        <Avatar sx={{ width: 40, height: 40, bgcolor: "primary.main" }}>
          {getInitials(user?.name)}
        </Avatar>
        <Box>
          <Typography variant="subtitle1" fontWeight={600}>
            {user?.name} {user?.surname}
          </Typography>
          <Typography variant="body2" color="text.secondary">
            {roleTranslations[user?.role] || user?.role}
          </Typography>
        </Box>
      </Box>
      <Divider sx={{ borderColor: "grey.200" }} />
      <List sx={{ p: 1 }}>
        {navItems.map((item) => (
          <ListItem key={item.text} disablePadding>
            <ListItemButton
              component={NavLink}
              to={item.path}
              end={item.path === "/"} // Important for root path matching
              sx={{
                borderRadius: "6px",
                "&.active": {
                  backgroundColor: "action.selected",
                  "& .MuiListItemIcon-root, & .MuiListItemText-primary": {
                    color: "primary.main",
                    fontWeight: 600,
                  },
                },
              }}
            >
              <ListItemIcon sx={{ minWidth: 40, color: "text.secondary" }}>
                {item.icon}
              </ListItemIcon>
              <ListItemText
                primary={item.text}
                primaryTypographyProps={{
                  color: "text.primary",
                  fontWeight: 500,
                }}
              />
            </ListItemButton>
          </ListItem>
        ))}
      </List>
    </div>
  );

  return (
    <Drawer
      variant="permanent"
      sx={{
        width: drawerWidth,
        flexShrink: 0,
        [`& .MuiDrawer-paper`]: {
          width: drawerWidth,
          boxSizing: "border-box",
          borderRight: "1px solid #E2E8F0",
          backgroundColor: "#FFFFFF",
        },
      }}
    >
      {drawerContent}
    </Drawer>
  );
};

export default Sidebar;

====================================================================
### Plik: ./frontend/src/components/layout/Header.js
====================================================================
import React, { useContext } from "react";
import {
  Box,
  Typography,
  IconButton,
  Tooltip,
  Badge,
  Menu,
  MenuItem,
  ListItemIcon,
} from "@mui/material";
import { useNavigate, useLocation } from "react-router-dom";
import { AuthContext } from "../../contexts/AuthContext";
import NotificationsIcon from "@mui/icons-material/Notifications";
import Logout from "@mui/icons-material/Logout";
import AccountCircleIcon from "@mui/icons-material/AccountCircle";

const getPageTitle = (pathname) => {
  const titles = {
    "/": "Dashboard",
    "/calendar": "Kalendarz",
    "/recommendations": "Rekomendacje i Propozycje",
    "/users": "Zarządzaj Użytkownikami",
    "/groups": "Zarządzaj Grupami",
    "/rooms": "Zarządzaj Salami",
    "/courses": "Zarządzaj Kursami",
  };
  return titles[pathname] || "System Rezerwacji Sal";
};

const Header = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { logout } = useContext(AuthContext);
  const [anchorEl, setAnchorEl] = React.useState(null);
  const open = Boolean(anchorEl);

  const handleMenu = (event) => setAnchorEl(event.currentTarget);
  const handleClose = () => setAnchorEl(null);

  const handleLogoutClick = () => {
    handleClose();
    logout();
    navigate("/login");
  };

  return (
    <Box
      sx={{
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        width: "100%",
        p: 2,
        mb: 2,
        backgroundColor: "background.default",
        borderBottom: "1px solid #E2E8F0",
      }}
    >
      <Typography variant="h5" component="h1" fontWeight={700}>
        {getPageTitle(location.pathname)}
      </Typography>

      <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
        <Tooltip title="Powiadomienia">
          <IconButton color="inherit">
            <Badge color="error" variant="dot" invisible={true}>
              <NotificationsIcon />
            </Badge>
          </IconButton>
        </Tooltip>

        <Tooltip title="Opcje użytkownika">
          <IconButton onClick={handleMenu} sx={{ p: 0 }}>
            <AccountCircleIcon sx={{ color: "text.secondary" }} />
          </IconButton>
        </Tooltip>

        <Menu
          anchorEl={anchorEl}
          open={open}
          onClose={handleClose}
          PaperProps={{
            elevation: 0,
            sx: {
              overflow: "visible",
              filter: "drop-shadow(0px 2px 8px rgba(0,0,0,0.15))",
              mt: 1.5,
              minWidth: 180,
            },
          }}
          transformOrigin={{ horizontal: "right", vertical: "top" }}
          anchorOrigin={{ horizontal: "right", vertical: "bottom" }}
        >
          <MenuItem onClick={handleLogoutClick}>
            <ListItemIcon>
              <Logout fontSize="small" />
            </ListItemIcon>
            Wyloguj
          </MenuItem>
        </Menu>
      </Box>
    </Box>
  );
};

export default Header;

====================================================================
### Plik: ./frontend/src/components/layout/PrivateRoute.js
====================================================================
import React, { useContext } from "react";
import { Navigate, Outlet } from "react-router-dom";
import { AuthContext } from "../../contexts/AuthContext";
import { Box } from "@mui/material";
import Sidebar from "./Sidebar";
import Header from "./Header";

const PrivateRoute = () => {
  const { isAuthenticated } = useContext(AuthContext);

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return (
    <Box sx={{ display: "flex" }}>
      <Sidebar />
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          bgcolor: "background.default",
          minHeight: "100vh",
          display: "flex",
          flexDirection: "column",
        }}
      >
        <Header />
        <Box sx={{ flexGrow: 1, p: 3, pt: 0 }}>
          <Outlet />
        </Box>
      </Box>
    </Box>
  );
};

export default PrivateRoute;

====================================================================
### Plik: ./frontend/src/theme/theme.js
====================================================================
import { createTheme } from "@mui/material/styles";

const theme = createTheme({
  palette: {
    primary: { main: "#1E293B" },
    secondary: { main: "#64748B" },
    background: { default: "#F8FAFC", paper: "#FFFFFF" },
    text: { primary: "#1E293B", secondary: "#64748B" },
    success: { main: "#10B981", light: "#E8F5E9", dark: "#1B5E20" },
    warning: { main: "#F59E0B" },
  },
  typography: {
    fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
    h4: { fontWeight: 700, color: "#1E293B" },
    h5: { fontWeight: 600, color: "#1E293B" },
    h6: { fontWeight: 600, color: "#334155" },
    subtitle1: { color: "#334155" },
    subtitle2: { color: "#64748B" },
    body1: { color: "#334155" },
    body2: { color: "#64748B" },
    button: { textTransform: "none", fontWeight: 600 },
  },
  shape: { borderRadius: 8 },
  components: {
    MuiButton: {
      defaultProps: { disableElevation: true },
      styleOverrides: {
        root: { borderRadius: 8, padding: "10px 22px" },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          boxShadow:
            "0px 1px 3px rgba(0, 0, 0, 0.05), 0px 1px 2px rgba(0, 0, 0, 0.06)",
          backgroundImage: "none",
        },
      },
    },
    MuiDataGrid: {
      styleOverrides: {
        root: { border: "none" },
        cell: { borderBottom: "1px solid #F1F5F9" },
        columnHeaders: {
          backgroundColor: "#F8FAFC",
          borderBottom: "1px solid #E2E8F0",
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: "#FFFFFF",
          color: "#1E293B",
          boxShadow: "0px 1px 4px rgba(0, 0, 0, 0.08)",
        },
      },
    },
    MuiAvatar: {
      styleOverrides: {
        root: {
          backgroundColor: "#334155",
          color: "#FFFFFF",
        },
      },
    },
  },
});

export default theme;

====================================================================
### Plik: ./frontend/src/hooks/useCrud.js
====================================================================
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "../api/apiService";

export const useCrud = (resourceName, endpoint) => {
  const queryClient = useQueryClient();

  const { data, isLoading, isError, error } = useQuery({
    queryKey: [resourceName],
    queryFn: () => apiRequest(endpoint),
  });

  const invalidateQuery = () => {
    queryClient.invalidateQueries({ queryKey: [resourceName] });
  };

  const createMutation = useMutation({
    mutationFn: (newItem) =>
      apiRequest(endpoint, { method: "POST", body: JSON.stringify(newItem) }),
    onSuccess: invalidateQuery,
  });

  const updateMutation = useMutation({
    mutationFn: ({ id, updatedItem }) =>
      apiRequest(`${endpoint}/${id}`, {
        method: "PUT",
        body: JSON.stringify(updatedItem),
      }),
    onSuccess: invalidateQuery,
  });

  const deleteMutation = useMutation({
    mutationFn: (id) => apiRequest(`${endpoint}/${id}`, { method: "DELETE" }),
    onSuccess: invalidateQuery,
  });

  return {
    items: data || [],
    isLoading,
    isError,
    error,
    createItem: createMutation.mutateAsync,
    updateItem: updateMutation.mutateAsync,
    deleteItem: deleteMutation.mutateAsync,
    isCreating: createMutation.isPending,
    isUpdating: updateMutation.isPending,
    isDeleting: deleteMutation.isPending,
  };
};

====================================================================
### Plik: ./frontend/src/api/apiService.js
====================================================================
export const apiRequest = async (endpoint, options = {}) => {
  const token = localStorage.getItem("token");
  const headers = {
    "Content-Type": "application/json",
    ...options.headers,
  };

  if (token) {
    headers.Authorization = `Bearer ${token}`;
  }

  // Używamy prostego endpointu, Nginx zajmie się resztą
  const requestUrl = `/api${endpoint}`;

  const response = await fetch(requestUrl, {
    ...options,
    headers,
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({
      detail: `HTTP error! status: ${response.status}`,
    }));
    throw new Error(errorData.detail || "An unknown error occurred.");
  }

  if (response.status === 204) {
    return null;
  }

  return response.json();
};

====================================================================
### Plik: ./frontend/src/api/authService.js
====================================================================
import { apiRequest } from "./apiService";

export const login = async (email, password) => {
  const response = await fetch(`/api/auth/token`, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({ username: email, password: password }),
  });
  if (!response.ok) {
    const errorData = await response
      .json()
      .catch(() => ({ detail: "Invalid credentials" }));
    throw new Error(errorData.detail);
  }
  const data = await response.json();
  localStorage.setItem("token", data.access_token);
  return data;
};

export const logout = () => {
  localStorage.removeItem("token");
};

export const isAuthenticated = () => !!localStorage.getItem("token");

export const getCurrentUser = async () => {
  return apiRequest("/auth/me");
};

====================================================================
### Plik: ./frontend/src/pages/LoginPage.js
====================================================================
import React, { useState, useContext } from "react";
import { useNavigate } from "react-router-dom";
import { useMutation } from "@tanstack/react-query";
import { AuthContext } from "../contexts/AuthContext";
import {
  TextField,
  Button,
  Box,
  Typography,
  Alert,
  Container,
  Paper,
  Avatar,
  CircularProgress,
} from "@mui/material";
import SchoolIcon from "@mui/icons-material/School";

const LoginPage = () => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const navigate = useNavigate();
  const { login } = useContext(AuthContext);

  const mutation = useMutation({
    mutationFn: () => login(email, password),
    onSuccess: () => {
      navigate("/", { replace: true });
    },
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    if (email && password) {
      mutation.mutate();
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Paper
        elevation={6}
        sx={{
          marginTop: 8,
          p: 4,
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
        }}
      >
        <Avatar sx={{ m: 1, bgcolor: "primary.main", width: 56, height: 56 }}>
          <SchoolIcon />
        </Avatar>
        <Typography component="h1" variant="h5">
          System Rezerwacji Sal
        </Typography>
        <Typography
          component="p"
          variant="body2"
          color="text.secondary"
          sx={{ mt: 1 }}
        >
          Wydział Zarządzania AGH
        </Typography>
        <Box component="form" onSubmit={handleSubmit} noValidate sx={{ mt: 3 }}>
          <TextField
            margin="normal"
            required
            fullWidth
            id="email"
            label="Adres Email"
            name="email"
            autoComplete="email"
            autoFocus
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            disabled={mutation.isPending}
          />
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Hasło"
            type="password"
            id="password"
            autoComplete="current-password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            disabled={mutation.isPending}
          />
          {mutation.isError && (
            <Alert severity="error" sx={{ mt: 2, width: "100%" }}>
              {mutation.error instanceof Error
                ? mutation.error.message
                : "Wystąpił nieznany błąd"}
            </Alert>
          )}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2, py: 1.5 }}
            disabled={mutation.isPending}
          >
            {mutation.isPending ? (
              <CircularProgress size={24} color="inherit" />
            ) : (
              "Zaloguj się"
            )}
          </Button>
        </Box>
      </Paper>
    </Container>
  );
};

export default LoginPage;

====================================================================
### Plik: ./frontend/src/pages/CoursesPage.js
====================================================================
import React, { useState, useMemo, useCallback } from "react";
import { Container, Stack, IconButton, Box } from "@mui/material";
import DeleteIcon from "@mui/icons-material/Delete";
import EditIcon from "@mui/icons-material/Edit";
import SchoolIcon from "@mui/icons-material/School";
import { useQuery } from "@tanstack/react-query";

import { useCrud } from "../hooks/useCrud";
import AdminDataGrid from "../features/Admin/AdminDataGrid";
import CourseFormDialog from "../features/Admin/CourseFormDialog";
import { apiRequest } from "../api/apiService";

const useIdToNameMap = (
  queryKey,
  endpoint,
  nameFormatter = (item) => item.name
) => {
  const { data = [] } = useQuery({
    queryKey,
    queryFn: () => apiRequest(endpoint),
  });
  return useMemo(
    () => new Map(data.map((item) => [item.id, nameFormatter(item)])),
    [data, nameFormatter]
  );
};

const CoursesPage = () => {
  const {
    items: courses,
    isLoading,
    isError,
    error,
    createItem,
    updateItem,
    deleteItem,
  } = useCrud("courses", "/courses");
  const teachersMap = useIdToNameMap(
    ["users"],
    "/users",
    (user) => `${user.name} ${user.surname}`
  );
  const groupsMap = useIdToNameMap(["groups"], "/groups");

  const [dialogOpen, setDialogOpen] = useState(false);
  const [currentCourse, setCurrentCourse] = useState(null);

  const handleAdd = () => {
    setCurrentCourse(null);
    setDialogOpen(true);
  };

  const handleEdit = useCallback((course) => {
    setCurrentCourse(course);
    setDialogOpen(true);
  }, []);

  const handleDelete = useCallback(
    async (id) => {
      if (window.confirm("Czy na pewno chcesz usunąć ten kurs?")) {
        await deleteItem(id).catch((e) => alert(`Błąd: ${e.message}`));
      }
    },
    [deleteItem]
  );

  const handleSave = async (courseData) => {
    try {
      if (currentCourse) {
        await updateItem({ id: currentCourse.id, updatedItem: courseData });
      } else {
        await createItem(courseData);
      }
      setDialogOpen(false);
    } catch (e) {
      console.error("Save failed", e);
      return e;
    }
  };

  const columns = useMemo(
    () => [
      { field: "id", headerName: "ID", width: 90 },
      {
        field: "name",
        headerName: "Nazwa Kursu",
        width: 300,
        renderCell: (params) => (
          <Box sx={{ display: "flex", alignItems: "center" }}>
            <SchoolIcon sx={{ mr: 1, color: "text.secondary" }} />
            {params.value}
          </Box>
        ),
      },
      {
        field: "teacher_id",
        headerName: "Prowadzący",
        flex: 1,
        valueGetter: (value) => teachersMap.get(value) || "Nieznany",
      },
      {
        field: "group_id",
        headerName: "Grupa",
        flex: 1,
        valueGetter: (value) => groupsMap.get(value) || "Nieznana",
      },
      {
        field: "actions",
        headerName: "Akcje",
        width: 120,
        sortable: false,
        renderCell: (params) => (
          <Stack direction="row" spacing={1}>
            <IconButton size="small" onClick={() => handleEdit(params.row)}>
              <EditIcon />
            </IconButton>
            <IconButton
              size="small"
              color="error"
              onClick={() => handleDelete(params.row.id)}
            >
              <DeleteIcon />
            </IconButton>
          </Stack>
        ),
      },
    ],
    [teachersMap, groupsMap, handleEdit, handleDelete]
  );

  return (
    <Container maxWidth="lg" sx={{ p: "0 !important" }}>
      <AdminDataGrid
        columns={columns}
        rows={courses}
        isLoading={isLoading || teachersMap.size === 0 || groupsMap.size === 0}
        isError={isError}
        error={error}
        onAddItem={handleAdd}
        toolbarConfig={{
          searchPlaceholder: "Szukaj po nazwie kursu...",
          addLabel: "Dodaj Kurs",
        }}
      />
      <CourseFormDialog
        open={dialogOpen}
        onClose={() => setDialogOpen(false)}
        onSave={handleSave}
        course={currentCourse}
      />
    </Container>
  );
};

export default CoursesPage;

====================================================================
### Plik: ./frontend/src/pages/UsersPage.js
====================================================================
import React, { useState, useMemo, useCallback } from "react";
import { Container, Stack, IconButton, Avatar } from "@mui/material";
import DeleteIcon from "@mui/icons-material/Delete";
import EditIcon from "@mui/icons-material/Edit";
import PersonIcon from "@mui/icons-material/Person";

import { useCrud } from "../hooks/useCrud";
import AdminDataGrid from "../features/Admin/AdminDataGrid";
import UserFormDialog from "../features/Admin/UserFormDialog";

const roleTranslations = {
  ADMIN: "Administrator",
  KOORDYNATOR: "Koordynator",
  PROWADZACY: "Prowadzący",
  STAROSTA: "Starosta",
};

const UsersPage = () => {
  const {
    items: users,
    isLoading,
    isError,
    error,
    createItem,
    updateItem,
    deleteItem,
  } = useCrud("users", "/users");
  const [dialogOpen, setDialogOpen] = useState(false);
  const [currentUser, setCurrentUser] = useState(null);

  const handleAdd = () => {
    setCurrentUser(null);
    setDialogOpen(true);
  };

  const handleEdit = useCallback((user) => {
    setCurrentUser(user);
    setDialogOpen(true);
  }, []);

  const handleDelete = useCallback(
    async (id) => {
      if (window.confirm("Czy na pewno chcesz usunąć tego użytkownika?")) {
        try {
          await deleteItem(id);
        } catch (e) {
          alert(`Błąd: ${e.message}`);
        }
      }
    },
    [deleteItem]
  );

  const handleSave = async (userData) => {
    try {
      if (currentUser) {
        const payload = { ...userData };
        if (!payload.password) {
          delete payload.password;
        }
        await updateItem({ id: currentUser.id, updatedItem: payload });
      } else {
        await createItem(userData, { endpoint: "/users/create" });
      }
      setDialogOpen(false);
    } catch (e) {
      console.error("Save failed", e);
      return e;
    }
  };

  const columns = useMemo(
    () => [
      { field: "id", headerName: "ID", width: 90 },
      {
        field: "avatar",
        headerName: "Avatar",
        width: 70,
        renderCell: () => (
          <Avatar>
            <PersonIcon />
          </Avatar>
        ),
        sortable: false,
      },
      { field: "name", headerName: "Imię", width: 150 },
      { field: "surname", headerName: "Nazwisko", width: 150 },
      { field: "email", headerName: "Email", flex: 1 },
      {
        field: "role",
        headerName: "Rola",
        width: 150,
        valueGetter: (value) => roleTranslations[value] || value,
      },
      {
        field: "actions",
        headerName: "Akcje",
        width: 120,
        sortable: false,
        renderCell: (params) => (
          <Stack direction="row" spacing={1}>
            <IconButton size="small" onClick={() => handleEdit(params.row)}>
              <EditIcon />
            </IconButton>
            <IconButton
              size="small"
              color="error"
              onClick={() => handleDelete(params.row.id)}
            >
              <DeleteIcon />
            </IconButton>
          </Stack>
        ),
      },
    ],
    [handleEdit, handleDelete]
  );

  return (
    <Container maxWidth="lg" sx={{ p: "0 !important" }}>
      <AdminDataGrid
        columns={columns}
        rows={users}
        isLoading={isLoading}
        isError={isError}
        error={error}
        onAddItem={handleAdd}
        toolbarConfig={{
          searchPlaceholder: "Szukaj po imieniu, nazwisku, emailu...",
          addLabel: "Dodaj użytkownika",
        }}
      />
      <UserFormDialog
        open={dialogOpen}
        onClose={() => setDialogOpen(false)}
        onSave={handleSave}
        user={currentUser}
      />
    </Container>
  );
};

export default UsersPage;

====================================================================
### Plik: ./frontend/src/pages/MyRecommendationsPage.js
====================================================================
import React, { useState, useMemo, useContext } from "react";
import {
  Box,
  Typography,
  Paper,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  List,
  ListItem,
  ListItemText,
  Divider,
  CircularProgress,
  Alert,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Grid,
} from "@mui/material";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "../api/apiService";
import { format } from "date-fns";
import { pl } from "date-fns/locale";
import { AuthContext } from "../contexts/AuthContext";
import AvailabilitySelector from "../features/Proposals/AvailabilitySelector";

const statusLabels = {
  PENDING: "Oczekujące",
  ACCEPTED: "Zaakceptowane",
  REJECTED: "Odrzucone",
  CANCELLED: "Anulowane",
};

const timeSlotMap = {
  1: "08:00-09:30",
  2: "09:45-11:15",
  3: "11:30-13:00",
  4: "13:15-14:45",
  5: "15:00-16:30",
  6: "16:45-18:15",
  7: "18:30-20:00",
};

const useRelatedRequests = (status) => {
  return useQuery({
    queryKey: ["related-requests", { status }],
    queryFn: () => {
      const params = new URLSearchParams({ limit: 1000 });
      if (status) params.append("status", status);
      return apiRequest(`/change-requests/related?${params.toString()}`);
    },
    select: (data) =>
      data.map((req) => ({
        ...req,
        course_event: req.course_event || {},
      })),
  });
};

const useCoursesMap = () => {
  const { data: courses = [] } = useQuery({
    queryKey: ["courses"],
    queryFn: () => apiRequest("/courses"),
  });
  return useMemo(() => new Map(courses.map((c) => [c.id, c.name])), [courses]);
};

const MyRecommendationsPage = () => {
  const queryClient = useQueryClient();
  const { user } = useContext(AuthContext);
  const [selectedStatus, setSelectedStatus] = useState("PENDING");
  const [selectedRequestId, setSelectedRequestId] = useState("");
  const [selectedProposal, setSelectedProposal] = useState(null);

  const { data: requests = [], isLoading: isLoadingRequests } =
    useRelatedRequests(selectedStatus);
  const coursesMap = useCoursesMap();

  const selectedRequest = useMemo(() => {
    return requests.find((req) => req.id === selectedRequestId) || null;
  }, [requests, selectedRequestId]);

  const { data: recommendations = [], isLoading: isLoadingRecommendations } =
    useQuery({
      queryKey: ["recommendations", selectedRequestId],
      queryFn: () => apiRequest(`/recommendations/${selectedRequestId}`),
      enabled: !!selectedRequestId,
    });

  const acceptMutation = useMutation({
    mutationFn: (proposalId) =>
      apiRequest(`/proposals/${proposalId}/accept`, { method: "POST" }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["related-requests"] });
      queryClient.invalidateQueries({
        queryKey: ["recommendations", selectedRequestId],
      });
      setSelectedProposal(null);
    },
  });

  const rejectMutation = useMutation({
    mutationFn: (proposalId) =>
      apiRequest(`/proposals/${proposalId}/reject`, { method: "POST" }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["related-requests"] });
      queryClient.invalidateQueries({
        queryKey: ["recommendations", selectedRequestId],
      });
      setSelectedProposal(null);
    },
  });

  const getRequestDisplayLabel = (req) => {
    const courseName =
      coursesMap.get(req.course_event?.course_id) || "Nieznany kurs";
    const eventDate = req.course_event?.day
      ? format(new Date(req.course_event.day), "dd.MM.yyyy", { locale: pl })
      : "Brak daty";
    return `${courseName} z dnia ${eventDate} - ${req.reason}`;
  };

  return (
    <Box>
      <Paper sx={{ p: 2, mb: 3 }}>
        <Grid container spacing={2}>
          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel>Status zgłoszenia</InputLabel>
              <Select
                value={selectedStatus}
                onChange={(e) => setSelectedStatus(e.target.value)}
                label="Status zgłoszenia"
              >
                <MenuItem value="">Wszystkie</MenuItem>
                {Object.entries(statusLabels).map(([val, lab]) => (
                  <MenuItem key={val} value={val}>
                    {lab}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>
          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel>Wybierz zgłoszenie</InputLabel>
              <Select
                value={selectedRequestId}
                onChange={(e) => setSelectedRequestId(e.target.value)}
                label="Wybierz zgłoszenie"
                disabled={isLoadingRequests}
              >
                {requests.map((req) => (
                  <MenuItem key={req.id} value={req.id}>
                    {getRequestDisplayLabel(req)}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>
        </Grid>
      </Paper>

      <Grid container spacing={3}>
        <Grid item xs={12} md={6}>
          {selectedRequest && selectedRequest.status === "PENDING" && (
            <AvailabilitySelector changeRequestId={selectedRequestId} />
          )}
          {selectedRequestId && selectedRequest?.status !== "PENDING" && (
            <Alert severity="info">
              To zgłoszenie zostało już przetworzone (
              {statusLabels[selectedRequest.status]}). Nie możesz już proponować
              terminów.
            </Alert>
          )}
        </Grid>

        <Grid item xs={12} md={6}>
          <Paper sx={{ p: 2 }}>
            <Typography variant="h6">Rekomendowane Terminy</Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
              Poniżej znajdują się terminy pasujące obu stronom.
            </Typography>
            {isLoadingRecommendations && <CircularProgress />}
            {!isLoadingRecommendations &&
              selectedRequestId &&
              recommendations.length === 0 && (
                <Alert severity="info">
                  Brak wspólnych terminów. Upewnij się, że obie strony wskazały
                  swoją dostępność.
                </Alert>
              )}
            {recommendations.length > 0 && (
              <List>
                {recommendations.map((rec) => (
                  <React.Fragment key={rec.id}>
                    <ListItem button onClick={() => setSelectedProposal(rec)}>
                      <ListItemText
                        primary={`Data: ${format(
                          new Date(rec.recommended_day),
                          "EEEE, dd.MM.yyyy",
                          { locale: pl }
                        )}`}
                        secondary={
                          <>{`Slot: ${
                            timeSlotMap[rec.recommended_slot_id]
                          } / Sala: ${rec.recommended_room?.name}`}</>
                        }
                      />
                    </ListItem>
                    <Divider />
                  </React.Fragment>
                ))}
              </List>
            )}
          </Paper>
        </Grid>
      </Grid>

      <Dialog
        open={!!selectedProposal}
        onClose={() => setSelectedProposal(null)}
      >
        <DialogTitle>Szczegóły propozycji</DialogTitle>
        <DialogContent>
          {selectedProposal && (
            <List>
              <ListItem>
                <ListItemText
                  primary="Data"
                  secondary={format(
                    new Date(selectedProposal.recommended_day),
                    "EEEE, dd.MM.yyyy",
                    { locale: pl }
                  )}
                />
              </ListItem>
              <ListItem>
                <ListItemText
                  primary="Slot"
                  secondary={timeSlotMap[selectedProposal.recommended_slot_id]}
                />
              </ListItem>
              <ListItem>
                <ListItemText
                  primary="Sala"
                  secondary={selectedProposal.recommended_room?.name}
                />
              </ListItem>
            </List>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setSelectedProposal(null)}>Anuluj</Button>
          <Button
            onClick={() =>
              rejectMutation.mutate(selectedProposal.source_proposal_id)
            }
            color="error"
            variant="outlined"
            disabled={rejectMutation.isPending}
          >
            Odrzuć
          </Button>
          <Button
            onClick={() =>
              acceptMutation.mutate(selectedProposal.source_proposal_id)
            }
            color="primary"
            variant="contained"
            disabled={acceptMutation.isPending}
          >
            Zaakceptuj
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default MyRecommendationsPage;

====================================================================
### Plik: ./frontend/src/pages/GroupsPage.js
====================================================================
import React, { useState, useMemo, useCallback } from "react";
import { Container, Stack, IconButton, Box } from "@mui/material";
import DeleteIcon from "@mui/icons-material/Delete";
import EditIcon from "@mui/icons-material/Edit";
import GroupIcon from "@mui/icons-material/Group";
import { useQuery } from "@tanstack/react-query";

import { useCrud } from "../hooks/useCrud";
import AdminDataGrid from "../features/Admin/AdminDataGrid";
import GroupFormDialog from "../features/Admin/GroupFormDialog";
import { apiRequest } from "../api/apiService";

const useUsersMap = () => {
  const { data: users = [] } = useQuery({
    queryKey: ["users"],
    queryFn: () => apiRequest("/users"),
  });
  return useMemo(
    () => new Map(users.map((u) => [u.id, `${u.name} ${u.surname}`])),
    [users]
  );
};

const GroupsPage = () => {
  const {
    items: groups,
    isLoading,
    isError,
    error,
    createItem,
    updateItem,
    deleteItem,
  } = useCrud("groups", "/groups");
  const usersMap = useUsersMap();
  const [dialogOpen, setDialogOpen] = useState(false);
  const [currentGroup, setCurrentGroup] = useState(null);

  const handleAdd = () => {
    setCurrentGroup(null);
    setDialogOpen(true);
  };

  const handleEdit = useCallback((group) => {
    setCurrentGroup(group);
    setDialogOpen(true);
  }, []);

  const handleDelete = useCallback(
    async (id) => {
      if (window.confirm("Czy na pewno chcesz usunąć tę grupę?")) {
        await deleteItem(id).catch((e) => alert(`Błąd: ${e.message}`));
      }
    },
    [deleteItem]
  );

  const handleSave = async (groupData) => {
    try {
      if (currentGroup) {
        await updateItem({ id: currentGroup.id, updatedItem: groupData });
      } else {
        await createItem(groupData);
      }
      setDialogOpen(false);
    } catch (e) {
      console.error("Save failed", e);
      return e;
    }
  };

  const columns = useMemo(
    () => [
      { field: "id", headerName: "ID", width: 90 },
      {
        field: "name",
        headerName: "Nazwa Grupy",
        width: 250,
        renderCell: (params) => (
          <Box sx={{ display: "flex", alignItems: "center" }}>
            <GroupIcon sx={{ mr: 1, color: "text.secondary" }} />
            {params.value}
          </Box>
        ),
      },
      { field: "year", headerName: "Rok", type: "number", width: 100 },
      {
        field: "leader_id",
        headerName: "Starosta",
        flex: 1,
        valueGetter: (value) => usersMap.get(value) || "Nieznany",
      },
      {
        field: "actions",
        headerName: "Akcje",
        width: 120,
        sortable: false,
        renderCell: (params) => (
          <Stack direction="row" spacing={1}>
            <IconButton size="small" onClick={() => handleEdit(params.row)}>
              <EditIcon />
            </IconButton>
            <IconButton
              size="small"
              color="error"
              onClick={() => handleDelete(params.row.id)}
            >
              <DeleteIcon />
            </IconButton>
          </Stack>
        ),
      },
    ],
    [usersMap, handleEdit, handleDelete]
  );

  return (
    <Container maxWidth="lg" sx={{ p: "0 !important" }}>
      <AdminDataGrid
        columns={columns}
        rows={groups}
        isLoading={isLoading || usersMap.size === 0}
        isError={isError}
        error={error}
        onAddItem={handleAdd}
        toolbarConfig={{
          searchPlaceholder: "Szukaj po nazwie grupy...",
          addLabel: "Dodaj Grupę",
        }}
      />
      <GroupFormDialog
        open={dialogOpen}
        onClose={() => setDialogOpen(false)}
        onSave={handleSave}
        group={currentGroup}
      />
    </Container>
  );
};

export default GroupsPage;

====================================================================
### Plik: ./frontend/src/pages/ChangeRequestsPage.js
====================================================================
import React, { useState, useContext, useMemo } from "react";
import { Box, Typography, Container, CircularProgress } from "@mui/material";
import { Calendar, dateFnsLocalizer, Views } from "react-big-calendar";
import { format, parse, startOfWeek, getDay } from "date-fns";
import { pl } from "date-fns/locale";
import { useQuery } from "@tanstack/react-query";

import { apiRequest } from "../api/apiService";
import { AuthContext } from "../contexts/AuthContext";
import EventDialog from "../features/Calendar/EventDialog";
import ChangeRequestDialog from "../features/Calendar/ChangeRequestDialog";

import "react-big-calendar/lib/css/react-big-calendar.css";

const locales = { pl: pl };
const localizer = dateFnsLocalizer({
  format,
  parse,
  startOfWeek: () => startOfWeek(new Date(), { weekStartsOn: 1 }),
  getDay,
  locales,
});
const availableViews = [Views.MONTH, Views.WEEK, Views.DAY, Views.AGENDA];

const calendarMessages = {
  date: "Data",
  time: "Czas",
  event: "Wydarzenie",
  allDay: "Cały dzień",
  week: "Tydzień",
  work_week: "Tydzień roboczy",
  day: "Dzień",
  month: "Miesiąc",
  previous: "Poprzedni",
  next: "Następny",
  yesterday: "Wczoraj",
  tomorrow: "Jutro",
  today: "Dziś",
  agenda: "Agenda",
  noEventsInRange: "Brak wydarzeń w tym zakresie.",
};

const getSlotTimes = (day, slot) => {
  const slotTimes = [
    { start: "08:00", end: "09:30" },
    { start: "09:45", end: "11:15" },
    { start: "11:30", end: "13:00" },
    { start: "13:15", end: "14:45" },
    { start: "15:00", end: "16:30" },
    { start: "16:45", end: "18:15" },
    { start: "18:30", end: "20:00" },
  ];
  const { start, end } = slotTimes[slot - 1];
  const startDate = new Date(`${day}T${start}`);
  const endDate = new Date(`${day}T${end}`);
  return { start: startDate, end: endDate };
};

const useCalendarEvents = () => {
  const { user } = useContext(AuthContext);

  const queryKey = useMemo(
    () => ["calendarEvents", user?.role, user?.id],
    [user]
  );

  const fetchEvents = async () => {
    let courses = await apiRequest("/courses");

    if (user.role === "PROWADZACY") {
      courses = courses.filter((c) => c.teacher_id === user.id);
    } else if (user.role === "STAROSTA") {
      const groups = await apiRequest("/groups");
      const myGroupIds = groups
        .filter((g) => g.leader_id === user.id)
        .map((g) => g.id);
      courses = courses.filter((c) => myGroupIds.includes(c.group_id));
    }

    const eventPromises = courses.map((course) =>
      apiRequest(`/courses/${course.id}/events`).then((events) =>
        events.map((event) => ({
          ...event,
          courseName: course.name,
          courseId: course.id,
        }))
      )
    );

    const eventsByCourse = await Promise.all(eventPromises);
    return eventsByCourse.flat();
  };

  const {
    data: rawEvents,
    isLoading,
    isError,
    error,
  } = useQuery({
    queryKey,
    queryFn: fetchEvents,
    enabled: !!user,
  });

  const calendarEvents = useMemo(() => {
    if (!rawEvents) return [];
    return rawEvents.map((event) => {
      const { start, end } = getSlotTimes(event.day, event.time_slot_id);
      return {
        ...event,
        id: `${event.courseId}-${event.id}`,
        title: event.courseName,
        start,
        end,
      };
    });
  }, [rawEvents]);

  return { events: calendarEvents, isLoading, isError, error };
};

const ChangeRequestsPage = () => {
  const { events, isLoading } = useCalendarEvents();
  const [selectedEvent, setSelectedEvent] = useState(null);
  const [eventDialogOpen, setEventDialogOpen] = useState(false);
  const [changeDialogOpen, setChangeDialogOpen] = useState(false);

  const handleSelectEvent = (event) => {
    setSelectedEvent(event);
    setEventDialogOpen(true);
  };

  const handleProposeChange = () => {
    setEventDialogOpen(false);
    setChangeDialogOpen(true);
  };

  return (
    <Container maxWidth="xl" sx={{ p: 0, height: "calc(100vh - 120px)" }}>
      {isLoading && (
        <Box
          sx={{
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            height: "100%",
          }}
        >
          <CircularProgress />
        </Box>
      )}
      <Calendar
        localizer={localizer}
        culture="pl"
        events={events}
        startAccessor="start"
        endAccessor="end"
        views={availableViews}
        onSelectEvent={handleSelectEvent}
        messages={calendarMessages}
        style={{
          opacity: isLoading ? 0.5 : 1,
          backgroundColor: "#FFFFFF",
          padding: "1rem",
          borderRadius: "8px",
        }}
      />

      <EventDialog
        event={selectedEvent}
        open={eventDialogOpen}
        onClose={() => setEventDialogOpen(false)}
        onProposeChange={handleProposeChange}
      />
      <ChangeRequestDialog
        event={selectedEvent}
        open={changeDialogOpen}
        onClose={() => setChangeDialogOpen(false)}
      />
    </Container>
  );
};

export default ChangeRequestsPage;

====================================================================
### Plik: ./frontend/src/pages/MainPage.js
====================================================================
import React, { useContext } from "react";
import {
  Box,
  Typography,
  Paper,
  Container,
  CircularProgress,
  Chip,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Avatar,
} from "@mui/material";
import { useQuery } from "@tanstack/react-query";
import { AuthContext } from "../contexts/AuthContext";
import { apiRequest } from "../api/apiService";
import { format } from "date-fns";
import CheckCircleOutlineIcon from "@mui/icons-material/CheckCircleOutline";
import EditIcon from "@mui/icons-material/Edit";
import HourglassTopIcon from "@mui/icons-material/HourglassTop";

const timeSlotMap = {
  1: "08:00 - 09:30",
  2: "09:45 - 11:15",
  3: "11:30 - 13:00",
  4: "13:15 - 14:45",
  5: "15:00 - 16:30",
  6: "16:45 - 18:15",
  7: "18:30 - 20:00",
};

const useUpcomingEvents = (user) => {
  return useQuery({
    queryKey: ["upcomingEvents", user?.id],
    queryFn: async () => {
      if (!user) return [];

      const courses = await apiRequest("/courses");
      let myCourses = [];
      if (user.role === "PROWADZACY") {
        myCourses = courses.filter((c) => c.teacher_id === user.id);
      } else if (user.role === "STAROSTA") {
        const groups = await apiRequest("/groups");
        const myGroupId = groups.find((g) => g.leader_id === user.id)?.id;
        if (myGroupId) {
          myCourses = courses.filter((c) => c.group_id === myGroupId);
        }
      } else {
        myCourses = courses; // Admin/Koordynator widzi wszystko
      }

      const eventPromises = myCourses.map(async (course) => {
        const events = await apiRequest(`/courses/${course.id}/events`);
        return events.map((e) => ({ ...e, courseName: course.name }));
      });
      const eventsByCourse = await Promise.all(eventPromises);

      const allEvents = eventsByCourse.flat();

      return allEvents
        .map((e) => ({ ...e, date: new Date(e.day) }))
        .filter((e) => e.date >= new Date() && !e.canceled)
        .sort((a, b) => a.date - b.date)
        .slice(0, 5);
    },
    enabled: !!user,
  });
};

const RecentActivity = () => {
  const activities = [
    {
      icon: <CheckCircleOutlineIcon color="success" />,
      text: "Reservation Confirmed",
      subject: "Room 201",
    },
    {
      icon: <EditIcon color="secondary" />,
      text: "Reservation Updated",
      subject: "Room 305",
    },
    {
      icon: <HourglassTopIcon color="warning" />,
      text: "Reservation Requested",
      subject: "Room 102",
    },
  ];

  return (
    <Paper sx={{ p: 2, mt: 4 }}>
      <Typography variant="h6" gutterBottom>
        Recent Activity
      </Typography>
      <List>
        {activities.map((activity, index) => (
          <ListItem key={index}>
            <ListItemIcon>
              <Avatar sx={{ bgcolor: "background.default" }}>
                {activity.icon}
              </Avatar>
            </ListItemIcon>
            <ListItemText
              primary={activity.text}
              secondary={activity.subject}
            />
          </ListItem>
        ))}
      </List>
    </Paper>
  );
};

const MainPage = () => {
  const { user } = useContext(AuthContext);
  const { data: upcomingEvents = [], isLoading: isLoadingEvents } =
    useUpcomingEvents(user);

  return (
    <Container maxWidth="lg" sx={{ p: "0 !important" }}>
      <Typography variant="h4" component="h2" gutterBottom>
        Welcome back, {user?.name}!
      </Typography>

      <Paper sx={{ p: 2 }}>
        <Typography variant="h6" gutterBottom>
          Upcoming Reservations
        </Typography>
        {isLoadingEvents ? (
          <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}>
            <CircularProgress />
          </Box>
        ) : upcomingEvents.length > 0 ? (
          <Box sx={{ overflowX: "auto" }}>
            <table style={{ width: "100%", borderCollapse: "collapse" }}>
              <thead>
                <tr>
                  {["Room", "Date", "Time", "Course", "Status"].map((head) => (
                    <th
                      key={head}
                      style={{
                        padding: "12px",
                        textAlign: "left",
                        borderBottom: "1px solid #E2E8F0",
                      }}
                    >
                      <Typography variant="subtitle2" color="text.secondary">
                        {head}
                      </Typography>
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {upcomingEvents.map((event) => (
                  <tr key={event.id}>
                    <td
                      style={{
                        padding: "12px",
                        borderBottom: "1px solid #F1F5F9",
                      }}
                    >
                      {event.room_id || "N/A"}
                    </td>
                    <td
                      style={{
                        padding: "12px",
                        borderBottom: "1px solid #F1F5F9",
                      }}
                    >
                      {format(event.date, "MMM dd, yyyy")}
                    </td>
                    <td
                      style={{
                        padding: "12px",
                        borderBottom: "1.5px solid #F1F5F9",
                      }}
                    >
                      {timeSlotMap[event.time_slot_id] || "N/A"}
                    </td>
                    <td
                      style={{
                        padding: "12px",
                        borderBottom: "1px solid #F1F5F9",
                      }}
                    >
                      {event.courseName || "N/A"}
                    </td>
                    <td
                      style={{
                        padding: "12px",
                        borderBottom: "1px solid #F1F5F9",
                      }}
                    >
                      <Chip
                        label="Confirmed"
                        color="success"
                        size="small"
                        sx={{
                          bgcolor: "success.light",
                          color: "success.dark",
                          fontWeight: 600,
                        }}
                      />
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </Box>
        ) : (
          <Typography sx={{ p: 2, textAlign: "center" }} color="text.secondary">
            No upcoming reservations.
          </Typography>
        )}
      </Paper>

      <RecentActivity />
    </Container>
  );
};

export default MainPage;

====================================================================
### Plik: ./frontend/src/pages/RoomsPage.js
====================================================================
import React, { useState, useMemo, useCallback } from "react";
import { Container, Stack, IconButton, Box } from "@mui/material";
import DeleteIcon from "@mui/icons-material/Delete";
import EditIcon from "@mui/icons-material/Edit";
import MeetingRoomIcon from "@mui/icons-material/MeetingRoom";

import { useCrud } from "../hooks/useCrud";
import AdminDataGrid from "../features/Admin/AdminDataGrid";
import RoomFormDialog from "../features/Admin/RoomFormDialog";

const roomTypeTranslations = {
  LECTURE_HALL: "Sala wykładowa",
  LABORATORY: "Laboratorium",
  SEMINAR_ROOM: "Sala seminaryjna",
  CONFERENCE_ROOM: "Sala konferencyjna",
  OTHER: "Inne",
};

const RoomsPage = () => {
  const {
    items: rooms,
    isLoading,
    isError,
    error,
    createItem,
    updateItem,
    deleteItem,
  } = useCrud("rooms", "/rooms");
  const [dialogOpen, setDialogOpen] = useState(false);
  const [currentRoom, setCurrentRoom] = useState(null);

  const handleAdd = () => {
    setCurrentRoom(null);
    setDialogOpen(true);
  };

  const handleEdit = useCallback((room) => {
    setCurrentRoom(room);
    setDialogOpen(true);
  }, []);

  const handleDelete = useCallback(
    async (id) => {
      if (window.confirm("Czy na pewno chcesz usunąć tę salę?")) {
        try {
          await deleteItem(id);
        } catch (e) {
          alert(`Błąd: ${e.message}`);
        }
      }
    },
    [deleteItem]
  );

  const handleSave = async (roomData) => {
    try {
      if (currentRoom) {
        await updateItem({ id: currentRoom.id, updatedItem: roomData });
      } else {
        await createItem(roomData);
      }
      setDialogOpen(false);
    } catch (e) {
      console.error("Save failed", e);
      return e;
    }
  };

  const columns = useMemo(
    () => [
      { field: "id", headerName: "ID", width: 90 },
      {
        field: "name",
        headerName: "Nazwa Sali",
        width: 200,
        renderCell: (params) => (
          <Box sx={{ display: "flex", alignItems: "center" }}>
            <MeetingRoomIcon sx={{ mr: 1, color: "text.secondary" }} />
            {params.value}
          </Box>
        ),
      },
      {
        field: "type",
        headerName: "Typ",
        width: 180,
        valueGetter: (value) => roomTypeTranslations[value] || value,
      },
      {
        field: "capacity",
        headerName: "Pojemność",
        type: "number",
        width: 120,
      },
      {
        field: "equipment",
        headerName: "Wyposażenie",
        flex: 1,
        valueGetter: (value) => value.map((eq) => eq.name).join(", "),
      },
      {
        field: "actions",
        headerName: "Akcje",
        width: 120,
        sortable: false,
        renderCell: (params) => (
          <Stack direction="row" spacing={1}>
            <IconButton size="small" onClick={() => handleEdit(params.row)}>
              <EditIcon />
            </IconButton>
            <IconButton
              size="small"
              color="error"
              onClick={() => handleDelete(params.row.id)}
            >
              <DeleteIcon />
            </IconButton>
          </Stack>
        ),
      },
    ],
    [handleEdit, handleDelete]
  );

  return (
    <Container maxWidth="lg" sx={{ p: "0 !important" }}>
      <AdminDataGrid
        columns={columns}
        rows={rooms}
        isLoading={isLoading}
        isError={isError}
        error={error}
        onAddItem={handleAdd}
        toolbarConfig={{
          searchPlaceholder: "Szukaj po nazwie lub wyposażeniu...",
          addLabel: "Dodaj Salę",
        }}
      />
      <RoomFormDialog
        open={dialogOpen}
        onClose={() => setDialogOpen(false)}
        onSave={handleSave}
        room={currentRoom}
      />
    </Container>
  );
};

export default RoomsPage;

====================================================================
### Plik: ./frontend/src/AppRoutes.js
====================================================================
import React, { useContext } from "react";
import { Routes, Route, Navigate } from "react-router-dom";
import { AuthContext } from "./contexts/AuthContext";

import PrivateRoute from "./components/layout/PrivateRoute";
import PublicRoute from "./components/layout/PublicRoute";
import { Box, CircularProgress } from "@mui/material";

import LoginPage from "./pages/LoginPage";
import MainPage from "./pages/MainPage";
import RoomsPage from "./pages/RoomsPage";
import UsersPage from "./pages/UsersPage";
import GroupsPage from "./pages/GroupsPage";
import CoursesPage from "./pages/CoursesPage";
import ChangeRequestsPage from "./pages/ChangeRequestsPage";
import MyRecommendationsPage from "./pages/MyRecommendationsPage";

const AppRoutes = () => {
  const { loading, isAuthenticated } = useContext(AuthContext);

  if (loading) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="100vh"
      >
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Routes>
      <Route element={<PublicRoute />}>
        <Route path="/login" element={<LoginPage />} />
      </Route>

      <Route element={<PrivateRoute />}>
        <Route path="/" element={<MainPage />} />
        <Route path="/rooms" element={<RoomsPage />} />
        <Route path="/users" element={<UsersPage />} />
        <Route path="/groups" element={<GroupsPage />} />
        <Route path="/courses" element={<CoursesPage />} />
        <Route path="/calendar" element={<ChangeRequestsPage />} />
        <Route path="/recommendations" element={<MyRecommendationsPage />} />
      </Route>

      <Route
        path="*"
        element={<Navigate to={isAuthenticated ? "/" : "/login"} replace />}
      />
    </Routes>
  );
};

export default AppRoutes;

====================================================================
### Plik: ./frontend/src/App.js
====================================================================
import React from "react";
import { BrowserRouter as Router } from "react-router-dom";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ThemeProvider, CssBaseline } from "@mui/material";
import { AdapterDateFns } from "@mui/x-date-pickers/AdapterDateFnsV3";
import { LocalizationProvider } from "@mui/x-date-pickers/LocalizationProvider";
import { pl } from "date-fns/locale";

import { AuthProvider } from "./contexts/AuthContext";
import AppRoutes from "./AppRoutes";
import theme from "./theme/theme";

import "@fontsource/inter/400.css";
import "@fontsource/inter/500.css";
import "@fontsource/inter/600.css";
import "@fontsource/inter/700.css";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={pl}>
        <ThemeProvider theme={theme}>
          <CssBaseline />
          <Router>
            <AuthProvider>
              <AppRoutes />
            </AuthProvider>
          </Router>
        </ThemeProvider>
      </LocalizationProvider>
    </QueryClientProvider>
  );
}

export default App;

====================================================================
### Plik: ./backend/routers/equipment.py
====================================================================
from typing import List

from database import get_db
from fastapi import APIRouter, Depends, HTTPException
from model import Equipment, User, UserRole
from routers.auth import role_required
from routers.schemas import EquipmentCreate, EquipmentResponse
from sqlalchemy.orm import Session
from starlette.status import (
    HTTP_200_OK,
    HTTP_201_CREATED,
    HTTP_204_NO_CONTENT,
    HTTP_404_NOT_FOUND,
    HTTP_409_CONFLICT,
)

router = APIRouter(prefix="/equipment", tags=["Equipment"])

@router.post("/", response_model=EquipmentResponse, status_code=HTTP_201_CREATED)
def create_equipment(
    equipment: EquipmentCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
):
    existing = db.query(Equipment).filter(Equipment.name == equipment.name).first()
    if existing:
        raise HTTPException(status_code=HTTP_409_CONFLICT, detail="Equipment with this name already exists")
    new_equipment = Equipment(**equipment.dict())
    db.add(new_equipment)
    db.commit()
    db.refresh(new_equipment)
    return new_equipment

@router.get("", response_model=List[EquipmentResponse])
@router.get("/", response_model=List[EquipmentResponse], include_in_schema=False)
def get_all_equipment(db: Session = Depends(get_db)):
    return db.query(Equipment).all()

@router.delete("/{equipment_id}", status_code=HTTP_204_NO_CONTENT)
def delete_equipment(
    equipment_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
):
    eq = db.query(Equipment).filter(Equipment.id == equipment_id).first()
    if not eq:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Equipment not found")
    db.delete(eq)
    db.commit()
    return None
====================================================================
### Plik: ./backend/routers/auth.py
====================================================================
from datetime import datetime, timedelta

from config import get_settings
from database import get_db
from fastapi import APIRouter, Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from model import User, UserRole
from passlib.context import CryptContext
from routers.schemas import Token, TokenData, UserResponse
from sqlalchemy.orm import Session
from starlette.status import (
    HTTP_401_UNAUTHORIZED,
    HTTP_403_FORBIDDEN,
)

settings = get_settings()
router = APIRouter(prefix="/auth", tags=["Authentication"])
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/token")
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: timedelta | None = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)

async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) -> User:
    credentials_exception = HTTPException(
        status_code=HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
        token_data = TokenData(email=email)
    except JWTError:
        raise credentials_exception
    user = db.query(User).filter(User.email == token_data.email).first()
    if user is None:
        raise credentials_exception
    return user

def role_required(allowed_roles: list[UserRole]):
    def role_checker(current_user: User = Depends(get_current_user)):
        if current_user.role not in allowed_roles:
            raise HTTPException(
                status_code=HTTP_403_FORBIDDEN,
                detail="You do not have permission to access this resource",
            )
        return current_user
    return role_checker

@router.post("/token", response_model=Token)
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = db.query(User).filter(User.email == form_data.username).first()
    if not user or not verify_password(form_data.password, user.password):
        raise HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(data={"sub": user.email}, expires_delta=access_token_expires)
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=UserResponse)
async def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user
====================================================================
### Plik: ./backend/routers/user.py
====================================================================
from typing import List
from database import get_db
from fastapi import APIRouter, Depends, HTTPException
from model import User, UserRole
from routers.auth import get_current_user, get_password_hash, role_required
from routers.schemas import UserCreate, UserResponse, UserUpdate
from sqlalchemy.orm import Session
from starlette.status import (
    HTTP_200_OK,
    HTTP_201_CREATED,
    HTTP_204_NO_CONTENT,
    HTTP_404_NOT_FOUND,
    HTTP_409_CONFLICT,
    HTTP_422_UNPROCESSABLE_ENTITY,
)

router = APIRouter(prefix="/users", tags=["Users"])

@router.get("", response_model=List[UserResponse])
@router.get("/", response_model=List[UserResponse], include_in_schema=False)
def get_users(db: Session = Depends(get_db), current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR]))):
    return db.query(User).all()

@router.post("", response_model=UserResponse)
@router.post("/", response_model=UserResponse, include_in_schema=False)
def create_user(user: UserCreate, db: Session = Depends(get_db), current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR]))):
    if db.query(User).filter(User.email == user.email).first():
        raise HTTPException(status_code=409, detail="Email already registered")
    hashed_password = get_password_hash(user.password)
    db_user = User(name=user.name, surname=user.surname, email=user.email, password=hashed_password, role=user.role)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@router.put("/{user_id}", response_model=UserResponse, status_code=HTTP_200_OK)
def update_user(
    user_id: int,
    user_update: UserUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN])),
) -> User:
    db_user = db.query(User).filter(User.id == user_id).first()
    if db_user is None:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="User not found")

    update_data = user_update.dict(exclude_unset=True)

    if "email" in update_data and update_data["email"] != db_user.email:
        if db.query(User).filter(User.email == update_data["email"]).first():
            raise HTTPException(status_code=HTTP_409_CONFLICT, detail="Email already in use")

    if "password" in update_data and update_data["password"]:
        update_data["password"] = get_password_hash(update_data["password"])
    elif "password" in update_data:
        del update_data["password"]

    for key, value in update_data.items():
        setattr(db_user, key, value)

    db.commit()
    db.refresh(db_user)
    return db_user

@router.delete("/{user_id}", status_code=HTTP_204_NO_CONTENT)
def delete_user(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN])),
) -> None:
    db_user = db.query(User).filter(User.id == user_id).first()
    if db_user is None:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="User not found")
    if db_user.id == current_user.id:
        raise HTTPException(status_code=400, detail="Cannot delete your own account")

    db.delete(db_user)
    db.commit()
    return None
====================================================================
### Plik: ./backend/routers/change_request.py
====================================================================
from datetime import datetime
from typing import List, Optional

from database import get_db
from fastapi import APIRouter, Depends, HTTPException, Query
from model import ChangeRequest, Course, CourseEvent, Group, User, ChangeRequestStatus, UserRole
from routers.auth import get_current_user
from routers.schemas import ChangeRequestCreate, ChangeRequestResponse, ChangeRequestUpdate
from sqlalchemy import or_
from sqlalchemy.orm import Session, joinedload
from starlette.status import HTTP_200_OK, HTTP_201_CREATED, HTTP_403_FORBIDDEN, HTTP_404_NOT_FOUND

router = APIRouter(prefix="/change-requests", tags=["Change Requests"])

@router.get("/related", response_model=List[ChangeRequestResponse], status_code=HTTP_200_OK)
def get_related_requests(
    status: Optional[ChangeRequestStatus] = Query(None, description="Optional status filter"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> List[ChangeRequestResponse]:
    # POPRAWKA: Używamy .scalar_subquery() aby uniknąć ostrzeżeń SAWarning
    teacher_course_ids = db.query(Course.id).filter(Course.teacher_id == current_user.id).scalar_subquery()
    
    leader_group_ids = db.query(Group.id).filter(Group.leader_id == current_user.id).scalar_subquery()
    leader_course_ids = db.query(Course.id).filter(Course.group_id.in_(leader_group_ids)).scalar_subquery()

    related_course_ids = db.query(Course.id).filter(
        or_(Course.id.in_(teacher_course_ids), Course.id.in_(leader_course_ids))
    ).scalar_subquery()
    
    related_event_ids = db.query(CourseEvent.id).filter(CourseEvent.course_id.in_(related_course_ids)).scalar_subquery()

    query = db.query(ChangeRequest).filter(
        or_(
            ChangeRequest.initiator_id == current_user.id,
            ChangeRequest.course_event_id.in_(related_event_ids),
        )
    ).options(joinedload(ChangeRequest.course_event))

    if status:
        query = query.filter(ChangeRequest.status == status)

    return query.order_by(ChangeRequest.created_at.desc()).all()

@router.post("/", response_model=ChangeRequestResponse, status_code=HTTP_201_CREATED)
def create_request(
    request_data: ChangeRequestCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> ChangeRequest:
    course_event = db.query(CourseEvent).filter(CourseEvent.id == request_data.course_event_id).first()
    if not course_event:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Course event not found")

    new_request = ChangeRequest(
        **request_data.dict(exclude={"created_at"}),
        initiator_id=current_user.id,
        status=ChangeRequestStatus.PENDING,
        created_at=datetime.utcnow()
    )
    db.add(new_request)
    db.commit()
    db.refresh(new_request)
    return new_request

@router.get("/{request_id}", response_model=ChangeRequestResponse, status_code=HTTP_200_OK)
def get_request_by_id(request_id: int, db: Session = Depends(get_db)) -> ChangeRequest:
    request = db.query(ChangeRequest).filter(ChangeRequest.id == request_id).first()
    if not request:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Change request not found")
    return request

@router.put("/{request_id}", response_model=ChangeRequestResponse, status_code=HTTP_200_OK)
def update_request(
    request_id: int,
    request_data: ChangeRequestUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> ChangeRequest:
    db_request = db.query(ChangeRequest).filter(ChangeRequest.id == request_id).first()
    if db_request is None:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Request not found")

    if db_request.initiator_id != current_user.id and current_user.role not in [UserRole.ADMIN, UserRole.KOORDYNATOR]:
        raise HTTPException(status_code=HTTP_403_FORBIDDEN, detail="Not authorized to update this request")
        
    update_data = request_data.dict(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_request, key, value)
        
    db.commit()
    db.refresh(db_request)
    return db_request
====================================================================
### Plik: ./backend/routers/change_recommendation.py
====================================================================
from typing import List
from database import get_db
from fastapi import APIRouter, Depends, HTTPException
from model import (
    AvailabilityProposal, ChangeRecomendation, ChangeRequest, CourseEvent,
    Equipment, Room, RoomUnavailability, User
)
from routers.auth import get_current_user
from routers.schemas import ChangeRecomendationResponse
from sqlalchemy import func, or_
from sqlalchemy.orm import Session

router = APIRouter(prefix="/recommendations", tags=["Change Recommendations"])

@router.get("/{change_request_id}", response_model=List[ChangeRecomendationResponse])
def get_recommendations(change_request_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)) -> List[ChangeRecomendation]:
    change_request = db.query(ChangeRequest).filter(ChangeRequest.id == change_request_id).first()
    if not change_request:
        raise HTTPException(status_code=404, detail="Change request not found")

    course_event = change_request.course_event
    teacher = course_event.course.teacher
    group_leader = course_event.course.group.leader
    
    if not teacher or not group_leader:
        raise HTTPException(status_code=404, detail="Could not determine both parties for the request.")

    teacher_proposals = db.query(AvailabilityProposal.day, AvailabilityProposal.time_slot_id).filter(
        AvailabilityProposal.change_request_id == change_request_id,
        AvailabilityProposal.user_id == teacher.id
    ).subquery()
    
    leader_proposals = db.query(AvailabilityProposal).filter(
        AvailabilityProposal.change_request_id == change_request_id,
        AvailabilityProposal.user_id == group_leader.id
    )
    
    common_proposals = leader_proposals.join(
        teacher_proposals,
        (AvailabilityProposal.day == teacher_proposals.c.day) & (AvailabilityProposal.time_slot_id == teacher_proposals.c.time_slot_id)
    ).all()
    
    if not common_proposals:
        return []

    recommendations = []
    processed_slots = set()

    for proposal in common_proposals:
        slot_key = (proposal.day, proposal.time_slot_id)
        if slot_key in processed_slots:
            continue
        processed_slots.add(slot_key)
        
        unavailable_by_block = db.query(RoomUnavailability.room_id).filter(
            RoomUnavailability.start_datetime <= proposal.day,
            RoomUnavailability.end_datetime >= proposal.day
        ).subquery()
        
        unavailable_by_event = db.query(CourseEvent.room_id).filter(
            CourseEvent.day == proposal.day,
            CourseEvent.time_slot_id == proposal.time_slot_id,
            CourseEvent.canceled == False,
            CourseEvent.room_id.isnot(None)
        ).subquery()

        base_query = db.query(Room).filter(
            Room.id.notin_(unavailable_by_block),
            Room.id.notin_(unavailable_by_event),
        )

        if change_request.minimum_capacity > 0:
            base_query = base_query.filter(Room.capacity >= change_request.minimum_capacity)
            
        if change_request.room_requirements:
            required_eq_names = [name.strip() for name in change_request.room_requirements.split(',') if name.strip()]
            if required_eq_names:
                base_query = base_query.join(Room.equipment).filter(
                    Equipment.name.in_(required_eq_names)
                ).group_by(Room.id).having(
                    func.count(Equipment.id) >= len(required_eq_names)
                )

        available_rooms = base_query.order_by(Room.capacity).all()
        
        for room in available_rooms:
            recommendations.append(
                ChangeRecomendation(
                    id=len(recommendations) + 1,
                    change_request_id=change_request_id,
                    recommended_day=proposal.day,
                    recommended_slot_id=proposal.time_slot_id,
                    recommended_room_id=room.id,
                    source_proposal_id=proposal.id,
                    recommended_room=room,
                    source_proposal=proposal
                )
            )

    # Logika priorytetyzacji zintegrowana z `main`
    # 1. Preferowanie terminów nie-wieczornych
    non_evening_recs = [rec for rec in recommendations if rec.recommended_slot_id not in [6, 7]]
    if len(non_evening_recs) > 0:
        recommendations = non_evening_recs

    # 2. Preferowanie terminów "doklejonych" do innych zajęć
    adjacent_recs = []
    for rec in recommendations:
        neighboring_events = db.query(CourseEvent.id).filter(
            CourseEvent.day == rec.recommended_day,
            or_(
                CourseEvent.time_slot_id == rec.recommended_slot_id + 1,
                CourseEvent.time_slot_id == rec.recommended_slot_id - 1
            )
        ).first()
        if neighboring_events:
            adjacent_recs.append(rec)
            
    if len(adjacent_recs) > 0:
        recommendations = adjacent_recs
            
    return recommendations
====================================================================
### Plik: ./backend/routers/__init__.py
====================================================================

====================================================================
### Plik: ./backend/routers/proposal.py
====================================================================
from typing import List
from database import get_db
from fastapi import APIRouter, Depends, HTTPException, Query
from model import (
    AvailabilityProposal,
    ChangeRequest,
    ChangeRequestStatus,
    CourseEvent,
    User,
    Room,
    Equipment,
)
from routers.auth import get_current_user
# POPRAWKA 1: Dodajemy brakujące importy
from routers.schemas import (
    ProposalCreate,
    ProposalResponse,
    ChangeRequestResponse, # <-- BRAKUJĄCY IMPORT
)
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import func
from starlette.status import (
    HTTP_200_OK,
    HTTP_201_CREATED,
    HTTP_204_NO_CONTENT,
    HTTP_400_BAD_REQUEST,
    HTTP_403_FORBIDDEN,
    HTTP_404_NOT_FOUND,
)

router = APIRouter(prefix="/proposals", tags=["Availability Proposals"])

@router.get("/", response_model=List[ProposalResponse], status_code=HTTP_200_OK)
def get_proposals(
    change_request_id: int = Query(..., description="Filter proposals by change request ID"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> List[AvailabilityProposal]:
    # Pobierz propozycje tylko bieżącego użytkownika dla danego zgłoszenia
    proposals = (
        db.query(AvailabilityProposal)
        .filter(
            AvailabilityProposal.change_request_id == change_request_id,
            AvailabilityProposal.user_id == current_user.id,
        )
        .all()
    )
    return proposals


@router.post("/", status_code=HTTP_201_CREATED, response_model=ProposalResponse)
def create_proposal(
    proposal_data: ProposalCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> AvailabilityProposal:
    change_request = (
        db.query(ChangeRequest)
        .filter(ChangeRequest.id == proposal_data.change_request_id)
        .first()
    )
    if not change_request:
        raise HTTPException(
            status_code=HTTP_404_NOT_FOUND, detail="Change request not found"
        )

    proposal_exists = (
        db.query(AvailabilityProposal)
        .filter(
            AvailabilityProposal.change_request_id == proposal_data.change_request_id,
            AvailabilityProposal.user_id == current_user.id,
            AvailabilityProposal.day == proposal_data.day,
            AvailabilityProposal.time_slot_id == proposal_data.time_slot_id,
        )
        .first()
    )
    if proposal_exists:
        raise HTTPException(
            status_code=HTTP_400_BAD_REQUEST,
            detail="You have already proposed this time slot.",
        )

    new_proposal = AvailabilityProposal(
        **proposal_data.dict(), user_id=current_user.id
    )
    db.add(new_proposal)
    db.commit()
    db.refresh(new_proposal)
    return new_proposal

# POPRAWKA 2: Zmieniamy logikę akceptacji
# Teraz endpoint przyjmuje ID rekomendacji, a nie propozycji.
# Ale żeby nie zmieniać frontendu, zmodyfikujemy logikę, aby działała z ID propozycji.
@router.post("/{proposal_id}/accept", response_model=ChangeRequestResponse)
def accept_proposal(
    proposal_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)
):
    # Znajdź rekomendację, która pochodzi z tej propozycji
    # To jest obejście, idealnie frontend powinien wysyłać ID rekomendacji
    recommendation_query = db.query(ChangeRecomendation).filter(ChangeRecomendation.source_proposal_id == proposal_id).first()
    if not recommendation_query:
        raise HTTPException(status_code=404, detail="Could not find a matching recommendation for this proposal. Ensure both parties have submitted availability.")

    change_request = recommendation_query.change_request
    if change_request.status != ChangeRequestStatus.PENDING:
        raise HTTPException(status_code=HTTP_400_BAD_REQUEST, detail="This request has already been processed.")

    original_event = change_request.course_event
    course = original_event.course
    group = course.group
    
    is_leader = current_user.id == group.leader_id
    is_teacher = current_user.id == course.teacher_id

    if not (is_leader or is_teacher):
        raise HTTPException(status_code=HTTP_403_FORBIDDEN, detail="Not authorized to accept this proposal")
        
    change_request.status = ChangeRequestStatus.ACCEPTED
    original_event.canceled = True
    
    # Utwórz nowe wydarzenie na podstawie DANYCH Z REKOMENDACJI
    new_event = CourseEvent(
        course_id=original_event.course_id,
        room_id=recommendation_query.recommended_room_id, # Użyj sali z rekomendacji
        day=recommendation_query.recommended_day, # Użyj dnia z rekomendacji
        time_slot_id=recommendation_query.recommended_slot_id, # Użyj slotu z rekomendacji
        canceled=False
    )
    db.add(new_event)
    
    # Opcjonalnie: Usuń wszystkie propozycje związane z tym zgłoszeniem
    db.query(AvailabilityProposal).filter(AvailabilityProposal.change_request_id == change_request.id).delete()

    db.commit()
    db.refresh(change_request)
    return change_request


@router.post("/{proposal_id}/reject", response_model=ChangeRequestResponse)
def reject_proposal(
    proposal_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)
):
    # Logika odrzucenia jest prostsza i może bazować na propozycji
    proposal = db.query(AvailabilityProposal).options(joinedload(AvailabilityProposal.change_request)).filter(AvailabilityProposal.id == proposal_id).first()
    if not proposal:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Proposal not found")

    change_request = proposal.change_request
    if change_request.status != ChangeRequestStatus.PENDING:
        raise HTTPException(status_code=HTTP_400_BAD_REQUEST, detail="This request has already been processed.")

    course = change_request.course_event.course
    group = course.group
    
    is_leader = current_user.id == group.leader_id
    is_teacher = current_user.id == course.teacher_id

    if not (is_leader or is_teacher):
        raise HTTPException(status_code=HTTP_403_FORBIDDEN, detail="Not authorized to reject this proposal")

    change_request.status = ChangeRequestStatus.REJECTED
    db.commit()
    db.refresh(change_request)
    return change_request


@router.delete("/{proposal_id}", status_code=HTTP_204_NO_CONTENT)
def delete_proposal(
    proposal_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> None:
    proposal = (
        db.query(AvailabilityProposal)
        .filter(AvailabilityProposal.id == proposal_id)
        .first()
    )
    if not proposal:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Proposal not found")

    if proposal.user_id != current_user.id:
        raise HTTPException(
            status_code=HTTP_403_FORBIDDEN, detail="Not authorized to delete this proposal"
        )

    db.delete(proposal)
    db.commit()
    return None
====================================================================
### Plik: ./backend/routers/room_unavailability.py
====================================================================
from typing import List
from database import get_db
from fastapi import APIRouter, Depends, HTTPException
from model import Room, RoomUnavailability, User, UserRole
from routers.auth import get_current_user, role_required
from routers.schemas import RoomUnavailabilityCreate, RoomUnavailabilityResponse, RoomUnavailabilityUpdate
from sqlalchemy import and_
from sqlalchemy.orm import Session
from starlette.status import (
    HTTP_200_OK,
    HTTP_201_CREATED,
    HTTP_204_NO_CONTENT,
    HTTP_400_BAD_REQUEST,
    HTTP_404_NOT_FOUND,
)

router = APIRouter(prefix="/room-unavailability", tags=["Room Unavailability"])

@router.get("/", response_model=List[RoomUnavailabilityResponse])
def get_room_unavailabilities(db: Session = Depends(get_db)) -> List[RoomUnavailability]:
    return db.query(RoomUnavailability).all()

@router.post("/", response_model=RoomUnavailabilityResponse, status_code=HTTP_201_CREATED)
def create_room_unavailability(
    unavailability: RoomUnavailabilityCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
) -> RoomUnavailability:
    if unavailability.start_datetime >= unavailability.end_datetime:
        raise HTTPException(status_code=HTTP_400_BAD_REQUEST, detail="End time must be after start time")
    if not db.query(Room).filter(Room.id == unavailability.room_id).first():
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Room not found")

    new_unavailability = RoomUnavailability(**unavailability.dict())
    db.add(new_unavailability)
    db.commit()
    db.refresh(new_unavailability)
    return new_unavailability

@router.delete("/{unavailability_id}", status_code=HTTP_204_NO_CONTENT)
def delete_room_unavailability(
    unavailability_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
) -> None:
    unavailability = db.query(RoomUnavailability).filter(RoomUnavailability.id == unavailability_id).first()
    if not unavailability:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Room unavailability not found")
    db.delete(unavailability)
    db.commit()
    return
====================================================================
### Plik: ./backend/routers/schemas.py
====================================================================
from datetime import date, datetime
from typing import Optional, List

from model import ChangeRequestStatus, RoomType, UserRole
from pydantic import BaseModel, EmailStr, Field

class OrmBase(BaseModel):
    class Config:
        from_attributes = True

class EquipmentBase(BaseModel):
    name: str = Field(..., min_length=2, max_length=100)

class EquipmentCreate(EquipmentBase):
    pass

class EquipmentResponse(EquipmentBase, OrmBase):
    id: int

class RoomBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=100)
    capacity: int = Field(..., gt=0)
    type: RoomType

class RoomCreate(RoomBase):
    equipment_ids: List[int] = []

class RoomUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=3, max_length=100)
    capacity: Optional[int] = Field(None, gt=0)
    type: Optional[RoomType] = None
    equipment_ids: Optional[List[int]] = None

class RoomResponse(RoomBase, OrmBase):
    id: int
    equipment: List[EquipmentResponse] = []

class UserBase(BaseModel):
    email: EmailStr
    name: str = Field(..., min_length=2, max_length=100)
    surname: str = Field(..., min_length=2, max_length=100)
    role: UserRole

class UserCreate(UserBase):
    password: str = Field(..., min_length=8)

class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    name: Optional[str] = Field(None, min_length=2, max_length=100)
    surname: Optional[str] = Field(None, min_length=2, max_length=100)
    password: Optional[str] = Field(None, min_length=8)
    role: Optional[UserRole] = None

class UserResponse(UserBase, OrmBase):
    id: int

class GroupBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=100)
    year: Optional[int] = Field(None, ge=1, le=5)
    leader_id: int

class GroupCreate(GroupBase):
    pass

class GroupUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=3, max_length=100)
    year: Optional[int] = Field(None, ge=1, le=5)
    leader_id: Optional[int] = None

class GroupResponse(GroupBase, OrmBase):
    id: int

class CourseBase(BaseModel):
    name: str
    teacher_id: int
    group_id: int

class CourseCreate(CourseBase):
    pass

class CourseUpdate(BaseModel):
    name: Optional[str] = None
    teacher_id: Optional[int] = None
    group_id: Optional[int] = None

class CourseResponse(CourseBase, OrmBase):
    id: int

class CourseEventBase(BaseModel):
    course_id: int
    room_id: Optional[int] = None
    day: date
    time_slot_id: int
    canceled: bool = False

class CourseEventCreate(CourseEventBase):
    pass

class CourseEventResponse(CourseEventBase, OrmBase):
    id: int

class ChangeRequestBase(BaseModel):
    reason: str
    room_requirements: Optional[str] = None
    minimum_capacity: int = Field(0, ge=0)

class ChangeRequestCreate(ChangeRequestBase):
    course_event_id: int

class ChangeRequestUpdate(BaseModel):
    status: Optional[ChangeRequestStatus] = None

class CourseEventForRequestResponse(OrmBase):
    id: int
    day: date
    course_id: int

class ChangeRequestResponse(ChangeRequestBase, OrmBase):
    id: int
    course_event_id: int
    initiator_id: int
    status: ChangeRequestStatus
    created_at: datetime
    course_event: CourseEventForRequestResponse

class ProposalBase(BaseModel):
    change_request_id: int
    day: date
    time_slot_id: int

class ProposalCreate(ProposalBase):
    pass

class ProposalResponse(ProposalBase, OrmBase):
    id: int
    user_id: int

class ChangeRecomendationBase(BaseModel):
    change_request_id: int
    recommended_day: date
    recommended_slot_id: int
    recommended_room_id: int
    source_proposal_id: Optional[int] = None

class ChangeRecomendationResponse(ChangeRecomendationBase, OrmBase):
    id: int
    recommended_room: Optional[RoomResponse] = None
    source_proposal: Optional[ProposalResponse] = None

class RoomUnavailabilityBase(BaseModel):
    room_id: int
    start_datetime: datetime
    end_datetime: datetime
    reason: Optional[str] = None

class RoomUnavailabilityCreate(RoomUnavailabilityBase):
    pass

class RoomUnavailabilityUpdate(BaseModel):
    start_datetime: Optional[datetime] = None
    end_datetime: Optional[datetime] = None
    reason: Optional[str] = None

class RoomUnavailabilityResponse(RoomUnavailabilityBase, OrmBase):
    id: int

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    email: Optional[str] = None
====================================================================
### Plik: ./backend/routers/group.py
====================================================================
from typing import List
from database import get_db
from fastapi import APIRouter, Depends, HTTPException
from model import Group, User, UserRole
from routers.auth import get_current_user, role_required
from routers.schemas import GroupCreate, GroupResponse, GroupUpdate
from sqlalchemy.orm import Session
from starlette.status import (
    HTTP_200_OK,
    HTTP_201_CREATED,
    HTTP_204_NO_CONTENT,
    HTTP_404_NOT_FOUND,
    HTTP_409_CONFLICT,
    HTTP_422_UNPROCESSABLE_ENTITY,
)

router = APIRouter(prefix="/groups", tags=["Groups"])

@router.get("", response_model=List[GroupResponse])
@router.get("/", response_model=List[GroupResponse], include_in_schema=False)
def get_groups(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    return db.query(Group).all()

@router.get("/{group_id}", status_code=HTTP_200_OK, response_model=GroupResponse)
def get_group(group_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)) -> Group:
    group = db.query(Group).filter(Group.id == group_id).first()
    if not group:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Group not found")
    return group

@router.post("", response_model=GroupResponse, status_code=HTTP_201_CREATED)
@router.post("/", response_model=GroupResponse, status_code=HTTP_201_CREATED, include_in_schema=False)
def create_group(
    group_data: GroupCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
) -> Group:
    leader = db.query(User).filter(User.id == group_data.leader_id).first()
    if not leader:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Leader user not found")
    if leader.role != UserRole.STAROSTA:
        raise HTTPException(status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail="The assigned leader must have the 'STAROSTA' role.")
    if db.query(Group).filter(Group.name == group_data.name).first():
        raise HTTPException(status_code=HTTP_409_CONFLICT, detail="Group with this name already exists")
    if db.query(Group).filter(Group.leader_id == group_data.leader_id).first():
        raise HTTPException(status_code=HTTP_409_CONFLICT, detail="This user is already a leader of another group")

    new_group = Group(**group_data.dict())
    db.add(new_group)
    db.commit()
    db.refresh(new_group)
    return new_group

@router.put("/{group_id}", status_code=HTTP_200_OK, response_model=GroupResponse)
def update_group(
    group_id: int,
    group_data: GroupUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
) -> Group:
    db_group = db.query(Group).filter(Group.id == group_id).first()
    if not db_group:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Group not found")

    update_data = group_data.dict(exclude_unset=True)

    if "leader_id" in update_data and update_data["leader_id"] is not None:
        leader = db.query(User).filter(User.id == update_data["leader_id"]).first()
        if not leader:
            raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Leader user not found")
        if leader.role != UserRole.STAROSTA:
            raise HTTPException(status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail="The assigned leader must have the 'STAROSTA' role.")
        existing_leadership = db.query(Group).filter(Group.leader_id == update_data["leader_id"], Group.id != group_id).first()
        if existing_leadership:
            raise HTTPException(status_code=HTTP_409_CONFLICT, detail="This user is already a leader of another group")

    if "name" in update_data and update_data["name"] != db_group.name:
        if db.query(Group).filter(Group.name == update_data["name"]).first():
            raise HTTPException(status_code=HTTP_409_CONFLICT, detail="Group with this name already exists")
            
    for key, value in update_data.items():
        setattr(db_group, key, value)
        
    db.commit()
    db.refresh(db_group)
    return db_group

@router.delete("/{group_id}", status_code=HTTP_204_NO_CONTENT)
def delete_group(
    group_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
) -> None:
    group = db.query(Group).filter(Group.id == group_id).first()
    if not group:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Group not found")
    db.delete(group)
    db.commit()
    return None
====================================================================
### Plik: ./backend/routers/courses.py
====================================================================
from typing import List
from database import get_db
from fastapi import APIRouter, Depends, HTTPException
from model import Course, CourseEvent, Group, Room, TimeSlots, User, UserRole
from routers.auth import get_current_user, role_required
from routers.schemas import (
    CourseCreate,
    CourseEventCreate,
    CourseEventResponse,
    CourseUpdate
)
from sqlalchemy.orm import Session
from starlette.status import (
    HTTP_200_OK,
    HTTP_201_CREATED,
    HTTP_204_NO_CONTENT,
    HTTP_404_NOT_FOUND,
    HTTP_409_CONFLICT,
)
from .schemas import CourseResponse

router = APIRouter(prefix="/courses", tags=["Courses"])

@router.post("", response_model=CourseResponse, status_code=HTTP_201_CREATED)
@router.post("/", response_model=CourseResponse, status_code=HTTP_201_CREATED, include_in_schema=False)
def create_course(
    course: CourseCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
) -> Course:
    teacher = db.query(User).filter(User.id == course.teacher_id, User.role == UserRole.PROWADZACY).first()
    if not teacher:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Teacher with PROWADZACY role not found")

    if not db.query(Group).filter(Group.id == course.group_id).first():
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Group not found")

    db_course = Course(**course.dict())
    db.add(db_course)
    db.commit()
    db.refresh(db_course)
    return db_course

@router.get("", response_model=List[CourseResponse])
@router.get("/", response_model=List[CourseResponse], include_in_schema=False)
def get_courses(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    return db.query(Course).all()


@router.get("/{course_id}", response_model=CourseResponse, status_code=HTTP_200_OK)
def get_course(course_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)) -> Course:
    course = db.query(Course).filter(Course.id == course_id).first()
    if not course:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Course not found")
    return course

@router.put("/{course_id}", response_model=CourseResponse, status_code=HTTP_200_OK)
def update_course(
    course_id: int,
    course_data: CourseUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
) -> Course:
    db_course = db.query(Course).filter(Course.id == course_id).first()
    if not db_course:
        raise HTTPException(status_code=404, detail="Course not found")

    update_data = course_data.dict(exclude_unset=True)
    if "teacher_id" in update_data:
        teacher = db.query(User).filter(User.id == update_data["teacher_id"], User.role == UserRole.PROWADZACY).first()
        if not teacher:
            raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Teacher with PROWADZACY role not found")
    
    if "group_id" in update_data:
        if not db.query(Group).filter(Group.id == update_data["group_id"]).first():
            raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Group not found")

    for key, value in update_data.items():
        setattr(db_course, key, value)
    
    db.commit()
    db.refresh(db_course)
    return db_course

@router.delete("/{course_id}", status_code=HTTP_204_NO_CONTENT)
def delete_course(
    course_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
) -> None:
    course = db.query(Course).filter(Course.id == course_id).first()
    if not course:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Course not found")
    db.delete(course)
    db.commit()
    return None

@router.post("/events", response_model=CourseEventResponse, status_code=HTTP_201_CREATED)
def create_event(
    event_data: CourseEventCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
) -> CourseEvent:
    if not db.query(Course).filter(Course.id == event_data.course_id).first():
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Course not found")
    if event_data.room_id and not db.query(Room).filter(Room.id == event_data.room_id).first():
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Room does not exist")
    if not db.query(TimeSlots).filter(TimeSlots.id == event_data.time_slot_id).first():
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Time slot does not exist")

    conflict = db.query(CourseEvent).filter(
        CourseEvent.room_id == event_data.room_id,
        CourseEvent.day == event_data.day,
        CourseEvent.time_slot_id == event_data.time_slot_id,
        CourseEvent.canceled == False,
    ).first()
    if conflict:
        raise HTTPException(status_code=HTTP_409_CONFLICT, detail=f"Room {event_data.room_id} is already booked.")

    new_event = CourseEvent(**event_data.dict())
    db.add(new_event)
    db.commit()
    db.refresh(new_event)
    return new_event

@router.get("/{course_id}/events", response_model=List[CourseEventResponse], status_code=HTTP_200_OK)
def get_events_for_course(course_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)) -> List[CourseEvent]:
    if not db.query(Course).filter(Course.id == course_id).first():
        raise HTTPException(status_code=404, detail="Course not found")
    return db.query(CourseEvent).filter(CourseEvent.course_id == course_id).all()

@router.get("/events/{event_id}", response_model=CourseEventResponse, status_code=HTTP_200_OK)
def get_course_event(event_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)) -> CourseEvent:
    course_event = db.query(CourseEvent).filter(CourseEvent.id == event_id).first()
    if not course_event:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Course event not found")
    return course_event
====================================================================
### Plik: ./backend/routers/room.py
====================================================================
from typing import List
from database import get_db
from fastapi import APIRouter, Depends, HTTPException
from model import Equipment, Room, User, UserRole
from routers.auth import get_current_user, role_required
from routers.schemas import RoomCreate, RoomResponse, RoomUpdate
from sqlalchemy.orm import Session
from starlette.status import (
    HTTP_200_OK,
    HTTP_201_CREATED,
    HTTP_204_NO_CONTENT,
    HTTP_404_NOT_FOUND,
    HTTP_409_CONFLICT,
)

router = APIRouter(prefix="/rooms", tags=["Rooms"])

@router.get("", response_model=List[RoomResponse])
@router.get("/", response_model=List[RoomResponse], include_in_schema=False)
def get_rooms(db: Session = Depends(get_db)):
    return db.query(Room).all()

@router.post("/", status_code=HTTP_201_CREATED, response_model=RoomResponse)
def create_room(
    room_data: RoomCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
) -> Room:
    if db.query(Room).filter(Room.name == room_data.name).first():
        raise HTTPException(status_code=HTTP_409_CONFLICT, detail="Room with this name already exists")

    new_room = Room(name=room_data.name, capacity=room_data.capacity, type=room_data.type)

    if room_data.equipment_ids:
        equipment_items = db.query(Equipment).filter(Equipment.id.in_(room_data.equipment_ids)).all()
        if len(equipment_items) != len(room_data.equipment_ids):
            raise HTTPException(status_code=404, detail="One or more equipment items not found")
        new_room.equipment = equipment_items

    db.add(new_room)
    db.commit()
    db.refresh(new_room)
    return new_room

@router.get("/{room_id}", status_code=HTTP_200_OK, response_model=RoomResponse)
def get_room(room_id: int, db: Session = Depends(get_db)) -> Room:
    room = db.query(Room).filter(Room.id == room_id).first()
    if not room:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Room not found")
    return room

@router.put("/{room_id}", status_code=HTTP_200_OK, response_model=RoomResponse)
def update_room(
    room_id: int,
    room_data: RoomUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
) -> Room:
    db_room = db.query(Room).filter(Room.id == room_id).first()
    if not db_room:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Room not found")

    update_data = room_data.dict(exclude_unset=True)

    if "name" in update_data and update_data["name"] != db_room.name:
        if db.query(Room).filter(Room.name == update_data["name"]).first():
            raise HTTPException(status_code=HTTP_409_CONFLICT, detail="Room with this name already exists")

    if "equipment_ids" in update_data:
        equipment_ids = update_data.pop("equipment_ids")
        if equipment_ids is not None:
            equipment_items = db.query(Equipment).filter(Equipment.id.in_(equipment_ids)).all()
            if len(equipment_items) != len(set(equipment_ids)):
                raise HTTPException(status_code=404, detail="One or more equipment items not found")
            db_room.equipment = equipment_items
        else:
            db_room.equipment = []

    for key, value in update_data.items():
        setattr(db_room, key, value)

    db.commit()
    db.refresh(db_room)
    return db_room

@router.delete("/{room_id}", status_code=HTTP_204_NO_CONTENT)
def delete_room(
    room_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(role_required([UserRole.ADMIN, UserRole.KOORDYNATOR])),
) -> None:
    room = db.query(Room).filter(Room.id == room_id).first()
    if not room:
        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail="Room not found")
    db.delete(room)
    db.commit()
    return None
====================================================================
### Plik: ./backend/config.py
====================================================================
import os
from functools import lru_cache

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """
    Central settings management for the application.
    Loads variables from environment variables, which are injected by Docker Compose.
    """
    DATABASE_URL: str
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 # 24 godziny

    model_config = SettingsConfigDict(env_file=".env", env_file_encoding='utf-8', extra='ignore')


@lru_cache()
def get_settings() -> Settings:
    """Returns a cached instance of the Settings."""
    return Settings()
====================================================================
### Plik: ./backend/Dockerfile
====================================================================
FROM python:3.11

ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

WORKDIR /app

RUN pip install poetry
RUN poetry config virtualenvs.in-project true

COPY pyproject.toml poetry.lock ./

RUN poetry install --no-root

COPY . .

EXPOSE 8000

ENV PATH="/app/.venv/bin:$PATH"

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
====================================================================
### Plik: ./backend/database.py
====================================================================
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base, sessionmaker

from config import get_settings

settings = get_settings()

engine = create_engine(settings.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
====================================================================
### Plik: ./backend/pyproject.toml
====================================================================
[tool.poetry]
name = "booking-system-backend"
version = "0.1.0"
description = "Backend for AGH WZ Room Booking System"
authors = ["Apiotr16st <piotrandres@student.agh.edu.pl>"]
readme = "README.md"
package-mode = false

[tool.poetry.dependencies]
python = ">=3.10"
uvicorn = { extras = ["standard"], version = ">=0.29.0" }
fastapi = ">=0.115.0,<0.116.0"
sqlalchemy = ">=2.0.40,<3.0.0"
psycopg2-binary = ">=2.9.9"
pydantic = { extras = ["email"], version = ">=2.11.3,<3.0.0" }
pydantic-settings = "^2.3.0"
python-jose = { extras = ["cryptography"], version = ">=3.3.0,<4.0.0" }
passlib = { extras = ["bcrypt"], version = ">=1.7.4,<2.0.0" }
python-multipart = ">=0.0.6,<0.1.0"

[tool.poetry.group.dev.dependencies]
ruff = "^0.4.4"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.ruff]
select = ["E", "F", "W", "I", "N", "D", "UP", "ANN", "Q"]
ignore = [
    "D203",
    "D212",
"ANN101",
    "ANN102",
]
line-length = 88
src = ["."]

[tool.ruff.lint.pydocstyle]
convention = "google"
====================================================================
### Plik: ./backend/__init__.py
====================================================================

====================================================================
### Plik: ./backend/create_tables.py
====================================================================
import sys
from config import get_settings
from database import Base, engine
from sqlalchemy import text

# Importuj wszystkie modele, aby SQLAlchemy je "zobaczyło"
from model import * 

def main():
    if '--force' not in sys.argv:
        print("This will ERASE ALL DATA in the database.")
        print("To proceed, run this script with the --force flag:")
        print("python create_tables.py --force")
        sys.exit(1)

    print("Connecting to the database...")
    with engine.connect() as conn:
        print("Connection successful.")
        print("Dropping all existing tables...")
        with conn.begin():
            conn.execute(text("DROP TABLE IF EXISTS room_equipment_association CASCADE;"))
            conn.execute(text("DROP TABLE IF EXISTS change_recommendations CASCADE;"))
            conn.execute(text("DROP TABLE IF EXISTS availability_proposals CASCADE;"))
            conn.execute(text("DROP TABLE IF EXISTS change_requests CASCADE;"))
            conn.execute(text("DROP TABLE IF EXISTS course_events CASCADE;"))
            conn.execute(text("DROP TABLE IF EXISTS room_unavailability CASCADE;"))
            conn.execute(text("DROP TABLE IF EXISTS courses CASCADE;"))
            conn.execute(text("DROP TABLE IF EXISTS rooms CASCADE;"))
            conn.execute(text("DROP TABLE IF EXISTS equipment CASCADE;"))
            conn.execute(text("DROP TABLE IF EXISTS groups CASCADE;"))
            conn.execute(text("DROP TABLE IF EXISTS users CASCADE;"))
            conn.execute(text("DROP TABLE IF EXISTS time_slots CASCADE;"))
            conn.execute(text("DROP TYPE IF EXISTS userrole;"))
            conn.execute(text("DROP TYPE IF EXISTS roomtype;"))
            conn.execute(text("DROP TYPE IF EXISTS changerequeststatus;"))
        print("All tables dropped.")

    print("Creating all tables from metadata...")
    Base.metadata.create_all(bind=engine)
    print("All tables created successfully.")

if __name__ == "__main__":
    main()
====================================================================
### Plik: ./backend/model.py
====================================================================
import enum
from datetime import datetime
from sqlalchemy import (
    Boolean,
    Column,
    Date,
    DateTime,
    Enum,
    ForeignKey,
    Integer,
    String,
    Text,
    Time,
    Table,
)
from sqlalchemy.orm import declarative_base, relationship

Base = declarative_base()

class UserRole(str, enum.Enum):
    ADMIN = "ADMIN"
    KOORDYNATOR = "KOORDYNATOR"
    PROWADZACY = "PROWADZACY"
    STAROSTA = "STAROSTA"

class ChangeRequestStatus(str, enum.Enum):
    PENDING = "PENDING"
    ACCEPTED = "ACCEPTED"
    REJECTED = "REJECTED"
    CANCELLED = "CANCELLED"

class RoomType(str, enum.Enum):
    LECTURE_HALL = "LECTURE_HALL"
    LABORATORY = "LABORATORY"
    SEMINAR_ROOM = "SEMINAR_ROOM"
    CONFERENCE_ROOM = "CONFERENCE_ROOM"
    OTHER = "OTHER"

room_equipment_association = Table(
    "room_equipment_association",
    Base.metadata,
    Column("room_id", Integer, ForeignKey("rooms.id", ondelete="CASCADE"), primary_key=True),
    Column("equipment_id", Integer, ForeignKey("equipment.id", ondelete="CASCADE"), primary_key=True),
)

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(150), unique=True, nullable=False, index=True)
    password = Column(String(255), nullable=False)
    name = Column(String(100), nullable=False)
    surname = Column(String(100), nullable=False)
    role = Column(Enum(UserRole), nullable=False)
    led_group = relationship("Group", back_populates="leader", uselist=False)
    taught_courses = relationship("Course", back_populates="teacher")
    initiated_requests = relationship("ChangeRequest", back_populates="initiator")
    availability_proposals = relationship("AvailabilityProposal", back_populates="user")

class Group(Base):
    __tablename__ = "groups"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False, unique=True)
    year = Column(Integer, nullable=True)
    leader_id = Column(Integer, ForeignKey("users.id"), unique=True, nullable=False)
    leader = relationship("User", back_populates="led_group")
    courses = relationship("Course", back_populates="group")

class Equipment(Base):
    __tablename__ = "equipment"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), unique=True, nullable=False)
    rooms = relationship("Room", secondary=room_equipment_association, back_populates="equipment")

class Room(Base):
    __tablename__ = "rooms"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False, unique=True)
    capacity = Column(Integer, nullable=False)
    type = Column(Enum(RoomType), nullable=False)
    equipment = relationship("Equipment", secondary=room_equipment_association, back_populates="rooms")
    course_events = relationship("CourseEvent", back_populates="room")
    unavailability = relationship("RoomUnavailability", back_populates="room", cascade="all, delete-orphan")
    change_recommendations = relationship("ChangeRecomendation", back_populates="recommended_room")

class RoomUnavailability(Base):
    __tablename__ = "room_unavailability"
    id = Column(Integer, primary_key=True, index=True)
    room_id = Column(Integer, ForeignKey("rooms.id"), nullable=False)
    start_datetime = Column(DateTime, nullable=False)
    end_datetime = Column(DateTime, nullable=False)
    reason = Column(Text, nullable=True)
    room = relationship("Room", back_populates="unavailability")

class Course(Base):
    __tablename__ = "courses"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(150), nullable=False)
    teacher_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    group_id = Column(Integer, ForeignKey("groups.id"), nullable=False)
    teacher = relationship("User", back_populates="taught_courses")
    group = relationship("Group", back_populates="courses")
    events = relationship("CourseEvent", back_populates="course", cascade="all, delete-orphan")

class TimeSlots(Base):
    __tablename__ = "time_slots"
    id = Column(Integer, primary_key=True)
    start_time = Column(Time, nullable=False)
    end_time = Column(Time, nullable=False)

class CourseEvent(Base):
    __tablename__ = "course_events"
    id = Column(Integer, primary_key=True, index=True)
    course_id = Column(Integer, ForeignKey("courses.id"), nullable=False)
    room_id = Column(Integer, ForeignKey("rooms.id"), nullable=True)
    time_slot_id = Column(Integer, ForeignKey("time_slots.id"), nullable=False)
    day = Column(Date, nullable=False)
    canceled = Column(Boolean, default=False)
    course = relationship("Course", back_populates="events")
    room = relationship("Room", back_populates="course_events")
    change_requests = relationship("ChangeRequest", back_populates="course_event", cascade="all, delete-orphan")

class ChangeRequest(Base):
    __tablename__ = "change_requests"
    id = Column(Integer, primary_key=True, index=True)
    course_event_id = Column(Integer, ForeignKey("course_events.id"), nullable=False)
    initiator_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    status = Column(Enum(ChangeRequestStatus), nullable=False, default=ChangeRequestStatus.PENDING)
    reason = Column(Text, nullable=False)
    room_requirements = Column(Text, nullable=True)
    minimum_capacity = Column(Integer, default=0)
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    course_event = relationship("CourseEvent", back_populates="change_requests", lazy="joined")
    initiator = relationship("User", back_populates="initiated_requests")
    availability_proposals = relationship("AvailabilityProposal", back_populates="change_request", cascade="all, delete-orphan")
    change_recommendations = relationship("ChangeRecomendation", back_populates="change_request", cascade="all, delete-orphan")

class AvailabilityProposal(Base):
    __tablename__ = "availability_proposals"
    id = Column(Integer, primary_key=True, index=True)
    change_request_id = Column(Integer, ForeignKey("change_requests.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    day = Column(Date, nullable=False)
    time_slot_id = Column(Integer, ForeignKey("time_slots.id"), nullable=False)
    accepted_by_leader = Column(Boolean, default=False)
    accepted_by_representative = Column(Boolean, default=False)
    change_request = relationship("ChangeRequest", back_populates="availability_proposals")
    user = relationship("User", back_populates="availability_proposals")

class ChangeRecomendation(Base):
    __tablename__ = "change_recommendations"
    id = Column(Integer, primary_key=True, index=True)
    change_request_id = Column(Integer, ForeignKey("change_requests.id"), nullable=False)
    recommended_day = Column(Date, nullable=False)
    recommended_slot_id = Column(Integer, ForeignKey("time_slots.id"), nullable=False)
    recommended_room_id = Column(Integer, ForeignKey("rooms.id"), nullable=False)
    source_proposal_id = Column(Integer, ForeignKey("availability_proposals.id"), nullable=True)
    recommended_room = relationship("Room", back_populates="change_recommendations", lazy="joined")
    change_request = relationship("ChangeRequest", back_populates="change_recommendations")
    source_proposal = relationship("AvailabilityProposal", lazy="joined")
====================================================================
### Plik: ./backend/example_data.py
====================================================================
from datetime import date, datetime, time, timedelta

from database import SessionLocal
from model import (
    AvailabilityProposal,
    ChangeRequest,
    Course,
    CourseEvent,
    Equipment,
    Group,
    Room,
    RoomType,
    TimeSlots,
    User,
    UserRole,
)
from routers.auth import get_password_hash


def populate_db():
    db = SessionLocal()
    try:
        if db.query(User).first():
            print("Database already contains data. Aborting population.")
            return

        # --- 1. Time Slots ---
        print("Creating time slots...")
        time_slots_data = [
            ("08:00", "09:30"), ("09:45", "11:15"), ("11:30", "13:00"),
            ("13:15", "14:45"), ("15:00", "16:30"), ("16:45", "18:15"),
            ("18:30", "20:00")
        ]
        time_slots = []
        for start_t, end_t in time_slots_data:
            ts = TimeSlots(start_time=time.fromisoformat(start_t), end_time=time.fromisoformat(end_t))
            db.add(ts)
            time_slots.append(ts)
        db.commit()

        # --- 2. Users ---
        print("Creating users...")
        users = {
            'admin': User(email="admin@example.com", password=get_password_hash("admin123"), name="Admin", surname="Systemu", role=UserRole.ADMIN),
            'koordynator': User(email="koord@example.com", password=get_password_hash("koord123"), name="Barbara", surname="Koordynator", role=UserRole.KOORDYNATOR),
            'teacher1': User(email="j.kowalski@example.com", password=get_password_hash("teach123"), name="Jan", surname="Kowalski", role=UserRole.PROWADZACY),
            'teacher2': User(email="p.zielinski@example.com", password=get_password_hash("teach123"), name="Piotr", surname="Zieliński", role=UserRole.PROWADZACY),
            'starosta1': User(email="a.nowak@example.com", password=get_password_hash("stud123"), name="Anna", surname="Nowak", role=UserRole.STAROSTA),
            'starosta2': User(email="k.wojcik@example.com", password=get_password_hash("stud123"), name="Kamil", surname="Wójcik", role=UserRole.STAROSTA),
        }
        db.add_all(users.values())
        db.commit()

        # --- 3. Groups ---
        print("Creating groups...")
        groups = {
            'g1': Group(name="Zarządzanie, Rok 1, Grupa A", year=1, leader_id=users['starosta1'].id),
            'g2': Group(name="Zarządzanie, Rok 2, Grupa C", year=2, leader_id=users['starosta2'].id),
        }
        db.add_all(groups.values())
        db.commit()
        
        # --- 4. Equipment ---
        print("Creating equipment...")
        equipments = {
            'proj': Equipment(name="Rzutnik"),
            'whiteboard': Equipment(name="Tablica interaktywna"),
            'pc_lab': Equipment(name="Pracownia komputerowa"),
        }
        db.add_all(equipments.values())
        db.commit()
        
        # --- 5. Rooms ---
        print("Creating rooms...")
        rooms = {
            'r101': Room(name="Sala 101", capacity=30, type=RoomType.LABORATORY, equipment=[equipments['proj'], equipments['pc_lab']]),
            'r205': Room(name="Sala 205", capacity=25, type=RoomType.SEMINAR_ROOM, equipment=[equipments['proj'], equipments['whiteboard']]),
            'aula_a': Room(name="Aula A", capacity=120, type=RoomType.LECTURE_HALL, equipment=[equipments['proj']]),
        }
        db.add_all(rooms.values())
        db.commit()

        # --- 6. Courses ---
        print("Creating courses...")
        courses = {
            'c1': Course(name="Podstawy Zarządzania", teacher_id=users['teacher1'].id, group_id=groups['g1'].id),
            'c2': Course(name="Marketing", teacher_id=users['teacher2'].id, group_id=groups['g2'].id),
        }
        db.add_all(courses.values())
        db.commit()
        
        # --- 7. Course Events ---
        print("Creating course events...")
        today = date.today()
        events = {
            'e1': CourseEvent(course_id=courses['c1'].id, room_id=rooms['r205'].id, day=today + timedelta(days=1), time_slot_id=time_slots[1].id),
            'e2': CourseEvent(course_id=courses['c2'].id, room_id=rooms['r101'].id, day=today + timedelta(days=2), time_slot_id=time_slots[3].id),
        }
        db.add_all(events.values())
        db.commit()

        # --- 8. Change Request Scenario ---
        print("Creating change request scenario...")
        change_req = ChangeRequest(
            course_event_id=events['e1'].id,
            initiator_id=users['starosta1'].id,
            reason="Konflikt z innym wydarzeniem uczelnianym",
            minimum_capacity=20,
            room_requirements="Rzutnik",
            created_at=datetime.utcnow()
        )
        db.add(change_req)
        db.commit()
        
        # --- 9. Availability Proposals ---
        print("Creating availability proposals...")
        prop1 = AvailabilityProposal(change_request_id=change_req.id, user_id=users['starosta1'].id, day=today + timedelta(days=8), time_slot_id=time_slots[2].id)
        prop2 = AvailabilityProposal(change_request_id=change_req.id, user_id=users['starosta1'].id, day=today + timedelta(days=8), time_slot_id=time_slots[3].id)
        prop3 = AvailabilityProposal(change_request_id=change_req.id, user_id=users['teacher1'].id, day=today + timedelta(days=8), time_slot_id=time_slots[3].id)
        prop4 = AvailabilityProposal(change_request_id=change_req.id, user_id=users['teacher1'].id, day=today + timedelta(days=9), time_slot_id=time_slots[4].id)
        db.add_all([prop1, prop2, prop3, prop4])
        db.commit()

        print("Database populated successfully!")

    except Exception as e:
        print(f"An error occurred: {e}")
        db.rollback()
    finally:
        db.close()
====================================================================
### Plik: ./backend/main.py
====================================================================
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from routers import (
    auth, change_recommendation, change_request, courses, equipment,
    group, proposal, room, room_unavailability, user
)

app = FastAPI(title="System Rezerwacji Sal AGH", version="1.0.0")

# Używamy podwójnych dekoratorów w routerach, więc nie potrzebujemy tu specjalnej konfiguracji.
app.include_router(auth.router)
app.include_router(user.router)
app.include_router(group.router)
app.include_router(equipment.router)
app.include_router(room.router)
app.include_router(room_unavailability.router)
app.include_router(courses.router)
app.include_router(change_request.router)
app.include_router(proposal.router)
app.include_router(change_recommendation.router)

origins = ["http://localhost:3000", "http://127.0.0.1:3000", "http://localhost"]
app.add_middleware(
    CORSMiddleware, allow_origins=origins, allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

@app.get("/")
def root():
    return {"message": "Welcome!"}
====================================================================
### Plik: ./backend/populate.py
====================================================================
import sys
from datetime import date
from example_data import populate_db

def main():
    if '--force' not in sys.argv:
        print("This will populate the database with example data.")
        print("This might create duplicates if run multiple times.")
        print("To proceed, run this script with the --force flag:")
        print("python populate.py --force")
        sys.exit(1)
        
    print("Populating database with example data...")
    populate_db()
    print("Done.")

if __name__ == "__main__":
    main()
====================================================================
### Plik: ./.dockerignore
====================================================================
# Git
.git
.gitignore

# Node
**/node_modules
**/npm-debug.log

# Python
**/__pycache__
**/*.py[cod]
**/.venv
**/*-venv
**/pip-cache
**/.ruff_cache

# IDE
**/.idea
**/.vscode

# Docker
.dockerignore
docker-compose.yml
====================================================================
### Plik: ./docker-compose.yml
====================================================================
services:
  # Serwis Bazy Danych
  db:
    image: postgres:15-alpine
    container_name: booking_system_db
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=admin
      - POSTGRES_DB=database
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U admin -d database"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Serwis Backendu
  backend:
    container_name: booking_system_backend
    build:
      context: ./backend
      dockerfile: Dockerfile
    volumes:
      - ./backend:/app
      - /app/.venv
    # ZMIANA: Tymczasowo wystawiamy port 8000
    ports:
      - "8000:8000"
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload
    environment:
      - DATABASE_URL=postgresql+psycopg2://admin:admin@db:5432/database
      - SECRET_KEY=twoj_bardzo_bezpieczny_sekretny_klucz_zmien_to_koniecznie
    depends_on:
      db:
        condition: service_healthy

  # Serwis Frontendu z Nginx
  frontend:
    container_name: booking_system_frontend
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "80:80"
    depends_on:
      - backend

volumes:
  postgres_data:

====================================================================
### Plik: ./openapi.json
====================================================================
{"openapi":"3.1.0","info":{"title":"FastAPI","version":"0.1.0"},"paths":{"/auth/token":{"post":{"tags":["authentication"],"summary":"Login For Access Token","description":"OAuth2 compatible token login, get an access token for future requests.\n\nArgs:\n    form_data (OAuth2PasswordRequestForm): Form data with username and password\n    db (Session): Database session\n\nRaises:\n    HTTPException: If authentication fails\n\nReturns:\n    dict: Access token and token type","operationId":"login_for_access_token_auth_token_post","requestBody":{"content":{"application/x-www-form-urlencoded":{"schema":{"$ref":"#/components/schemas/Body_login_for_access_token_auth_token_post"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Token"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/auth/register":{"post":{"tags":["authentication"],"summary":"Register User","description":"Register a new user.\n\nArgs:\n    user (UserCreate): User registration data\n    db (Session): Database session\n\nRaises:\n    HTTPException: If email already exists or group is invalid\n\nReturns:\n    dict: Success message","operationId":"register_user_auth_register_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UserCreate"}}},"required":true},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"additionalProperties":true,"type":"object","title":"Response Register User Auth Register Post"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/auth/me":{"get":{"tags":["authentication"],"summary":"Read Users Me","description":"Get current user information.\n\nArgs:\n    current_user (User): The currently authenticated user\n\nReturns:\n    User: The user object of the authenticated user","operationId":"read_users_me_auth_me_get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/UserResponse"}}}}},"security":[{"OAuth2PasswordBearer":[]}]}},"/groups/":{"get":{"tags":["groups"],"summary":"Get Groups","description":"Retrieve a paginated list of all groups.\n\nArgs:\n    skip (int, optional): Number of records to skip. Defaults to 0.\n    limit (int, optional): Maximum number of records to return. Defaults to 10.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nReturns:\n    list[Group]: List of group objects.","operationId":"get_groups_groups__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"skip","in":"query","required":false,"schema":{"type":"integer","default":0,"title":"Skip"}},{"name":"limit","in":"query","required":false,"schema":{"type":"integer","default":10,"title":"Limit"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/GroupResponse"},"title":"Response Get Groups Groups  Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"post":{"tags":["groups"],"summary":"Create Group","description":"Create a new group.\n\nArgs:\n    group (GroupCreate): Group data for creation.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If user is not found, year is invalid, or leader is not a STAROSTA.\n\nReturns:\n    Group: The newly created group object.","operationId":"create_group_groups__post","security":[{"OAuth2PasswordBearer":[]}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/GroupCreate"}}}},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/GroupResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/groups/{group_id}":{"get":{"tags":["groups"],"summary":"Get Group","description":"Retrieve a single group by ID.\n\nArgs:\n    group_id (int): ID of the group to retrieve.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If group with the specified ID is not found.\n\nReturns:\n    Group: The requested group object.","operationId":"get_group_groups__group_id__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"group_id","in":"path","required":true,"schema":{"type":"integer","title":"Group Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/GroupResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"put":{"tags":["groups"],"summary":"Update Group","description":"Update an existing group.\n\nArgs:\n    group_id (int): ID of the group to update.\n    group (GroupUpdate): Updated group data.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If group or user is not found, year is invalid, or leader is not a STAROSTA.\n\nReturns:\n    Group: The updated group object.","operationId":"update_group_groups__group_id__put","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"group_id","in":"path","required":true,"schema":{"type":"integer","title":"Group Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/GroupUpdate"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/GroupResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["groups"],"summary":"Delete Group","description":"Delete a group by ID.\n\nArgs:\n    group_id (int): ID of the group to delete.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If group with the specified ID is not found.","operationId":"delete_group_groups__group_id__delete","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"group_id","in":"path","required":true,"schema":{"type":"integer","title":"Group Id"}}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/users/":{"get":{"tags":["users"],"summary":"Get Users","description":"Retrieve a paginated list of all users.\n\nArgs:\n    skip (int, optional): Number of records to skip. Defaults to 0.\n    limit (int, optional): Maximum number of records to return. Defaults to 10.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nReturns:\n    list[User]: List of user objects.","operationId":"get_users_users__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"skip","in":"query","required":false,"schema":{"type":"integer","default":0,"title":"Skip"}},{"name":"limit","in":"query","required":false,"schema":{"type":"integer","default":10,"title":"Limit"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UserResponse"},"title":"Response Get Users Users  Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/users/{user_id}":{"get":{"tags":["users"],"summary":"Get User","description":"Retrieve a single user by ID.\n\nArgs:\n    user_id (int): ID of the user to retrieve.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If user with the specified ID is not found.\n\nReturns:\n    User: The requested user object.","operationId":"get_user_users__user_id__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"user_id","in":"path","required":true,"schema":{"type":"integer","title":"User Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/UserResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"put":{"tags":["users"],"summary":"Update User","description":"Update an existing user.\n\nArgs:\n    user_id (int): ID of the user to update.\n    user (UserCreate): Updated user data.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If user is not found or email is already registered by another user.\n\nReturns:\n    User: The updated user object.","operationId":"update_user_users__user_id__put","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"user_id","in":"path","required":true,"schema":{"type":"integer","title":"User Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UserCreate"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/UserResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["users"],"summary":"Delete User","description":"Delete a user by ID.\n\nArgs:\n    user_id (int): ID of the user to delete.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If user with the specified ID is not found.","operationId":"delete_user_users__user_id__delete","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"user_id","in":"path","required":true,"schema":{"type":"integer","title":"User Id"}}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/users/create":{"post":{"tags":["users"],"summary":"Create User","description":"Create a new user.\n\nArgs:\n    user (UserCreate): User data for creation.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If email is already registered.\n\nReturns:\n    User: The newly created user object.","operationId":"create_user_users_create_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UserCreate"}}},"required":true},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/UserResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"security":[{"OAuth2PasswordBearer":[]}]}},"/rooms/":{"get":{"tags":["rooms"],"summary":"Get Rooms","description":"Retrieve a paginated list of all rooms.\n\nArgs:\n    skip (int, optional): Number of records to skip. Defaults to 0.\n    limit (int, optional): Maximum number of records to return. Defaults to 10.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nReturns:\n    list[Room]: List of room objects.","operationId":"get_rooms_rooms__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"skip","in":"query","required":false,"schema":{"type":"integer","default":0,"title":"Skip"}},{"name":"limit","in":"query","required":false,"schema":{"type":"integer","default":10,"title":"Limit"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/RoomResponse"},"title":"Response Get Rooms Rooms  Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"post":{"tags":["rooms"],"summary":"Create Room","description":"Create a new room.\n\nArgs:\n    room (RoomCreate): Room data for creation.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If capacity is not positive, room name already exists, or room type is invalid.\n\nReturns:\n    Room: The newly created room object.","operationId":"create_room_rooms__post","security":[{"OAuth2PasswordBearer":[]}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/RoomCreate"}}}},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/RoomResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/rooms/check-availability":{"get":{"tags":["rooms"],"summary":"Get Available Rooms","description":"Find all available rooms matching the criteria within a specified time interval.\n\nArgs:\n    seats (int): Minimum number of seats required in the room.\n    room_type (RoomType): Type of room required.\n    start (date): Start date of the desired interval.\n    end (date): End date of the desired interval.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nRaises:\n    HTTPException: If end time is not greater than start time or if seats is not positive.\n\nReturns:\n    list[Room]: List of available rooms matching the criteria.","operationId":"get_available_rooms_rooms_check_availability_get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"seats","in":"query","required":true,"schema":{"type":"integer","title":"Seats"}},{"name":"room_type","in":"query","required":true,"schema":{"$ref":"#/components/schemas/RoomType"}},{"name":"start","in":"query","required":true,"schema":{"type":"string","format":"date","description":"Start of desired interval","title":"Start"},"description":"Start of desired interval"},{"name":"end","in":"query","required":true,"schema":{"type":"string","format":"date","description":"End of desired interval","title":"End"},"description":"End of desired interval"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/RoomResponse"},"title":"Response Get Available Rooms Rooms Check Availability Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/rooms/check-availability/{room_id}":{"get":{"tags":["rooms"],"summary":"Get Room Availability","description":"Check if a specific room is available during a given time interval.\n\nArgs:\n    room_id (int): ID of the room to check.\n    start (datetime): Start datetime of the interval.\n    end (datetime): End datetime of the interval.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nRaises:\n    HTTPException: If end time is not greater than start time or if room is not found.\n\nReturns:\n    dict: Dictionary with 'available' key indicating room availability.","operationId":"get_room_availability_rooms_check_availability__room_id__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"room_id","in":"path","required":true,"schema":{"type":"integer","title":"Room Id"}},{"name":"start","in":"query","required":true,"schema":{"type":"string","format":"date-time","description":"Start of desired interval","title":"Start"},"description":"Start of desired interval"},{"name":"end","in":"query","required":true,"schema":{"type":"string","format":"date-time","description":"End of desired interval","title":"End"},"description":"End of desired interval"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","additionalProperties":true,"title":"Response Get Room Availability Rooms Check Availability  Room Id  Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/rooms/{room_id}":{"get":{"tags":["rooms"],"summary":"Get Room","description":"Retrieve a single room by its ID.\n\nArgs:\n    room_id (int): ID of the room to retrieve.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nRaises:\n    HTTPException: If room with the specified ID is not found.\n\nReturns:\n    Room: The requested room object.","operationId":"get_room_rooms__room_id__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"room_id","in":"path","required":true,"schema":{"type":"integer","title":"Room Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/RoomResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"put":{"tags":["rooms"],"summary":"Update Room","description":"Update an existing room.\n\nArgs:\n    room_id (int): ID of the room to update.\n    room (RoomUpdate): Updated room data.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If room is not found, capacity is not positive, room name already exists,\n                  or room type is invalid.\n\nReturns:\n    Room: The updated room object.","operationId":"update_room_rooms__room_id__put","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"room_id","in":"path","required":true,"schema":{"type":"integer","title":"Room Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/RoomUpdate"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/RoomResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["rooms"],"summary":"Delete Room","description":"Delete a room by ID.\n\nArgs:\n    room_id (int): ID of the room to delete.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If room with the specified ID is not found.","operationId":"delete_room_rooms__room_id__delete","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"room_id","in":"path","required":true,"schema":{"type":"integer","title":"Room Id"}}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/proposals/":{"get":{"tags":["proposals"],"summary":"Get Proposals","description":"Retrieve a paginated list of all availability proposals.\n\nArgs:\n    skip (int, optional): Number of records to skip. Defaults to 0.\n    limit (int, optional): Maximum number of records to return. Defaults to 10.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nReturns:\n    list[AvailabilityProposal]: List of availability proposals.","operationId":"get_proposals_proposals__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"skip","in":"query","required":false,"schema":{"type":"integer","default":0,"title":"Skip"}},{"name":"limit","in":"query","required":false,"schema":{"type":"integer","default":10,"title":"Limit"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ProposalResponse"},"title":"Response Get Proposals Proposals  Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"post":{"tags":["proposals"],"summary":"Create Proposal","description":"Create a new availability proposal.\n\nArgs:\n    proposal (ProposalCreate): Data for the new proposal.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nRaises:\n    HTTPException: If change request or user is not found, or if a proposal already exists\n                  for the same user and time slot.\n\nReturns:\n    AvailabilityProposal: The newly created proposal.","operationId":"create_proposal_proposals__post","security":[{"OAuth2PasswordBearer":[]}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ProposalCreate"}}}},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ProposalResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/proposals/{proposal_id}":{"get":{"tags":["proposals"],"summary":"Get Proposal","description":"Retrieve a specific availability proposal by ID.\n\nArgs:\n    proposal_id (int): ID of the proposal to retrieve.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nRaises:\n    HTTPException: If proposal with the specified ID is not found.\n\nReturns:\n    AvailabilityProposal: The requested proposal.","operationId":"get_proposal_proposals__proposal_id__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"proposal_id","in":"path","required":true,"schema":{"type":"integer","title":"Proposal Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ProposalResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"put":{"tags":["proposals"],"summary":"Update Proposal","description":"Update an existing availability proposal.\n\nArgs:\n    proposal_id (int): ID of the proposal to update.\n    proposal (ProposalUpdate): Updated proposal data.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nRaises:\n    HTTPException: If proposal or user is not found.\n\nReturns:\n    AvailabilityProposal: The updated proposal.","operationId":"update_proposal_proposals__proposal_id__put","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"proposal_id","in":"path","required":true,"schema":{"type":"integer","title":"Proposal Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ProposalUpdate"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ProposalResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["proposals"],"summary":"Delete Proposal","description":"Delete an availability proposal.\n\nArgs:\n    proposal_id (int): ID of the proposal to delete.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nRaises:\n    HTTPException: If proposal is not found.","operationId":"delete_proposal_proposals__proposal_id__delete","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"proposal_id","in":"path","required":true,"schema":{"type":"integer","title":"Proposal Id"}}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/proposals/{change_request_id}":{"get":{"tags":["proposals"],"summary":"Get Change Request Proposals","description":"Retrieve all proposals for a specific change request.\n\nArgs:\n    change_request_id (int): ID of the change request.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nRaises:\n    HTTPException: If no proposals are found for the change request.\n\nReturns:\n    list[AvailabilityProposal]: List of proposals for the specified change request.","operationId":"get_change_request_proposals_proposals__change_request_id__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"change_request_id","in":"path","required":true,"schema":{"type":"integer","title":"Change Request Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ProposalResponse"},"title":"Response Get Change Request Proposals Proposals  Change Request Id  Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/proposals/{proposal_id}/changestatus/leader":{"post":{"tags":["proposals"],"summary":"Change Status By Leader","operationId":"change_status_by_leader_proposals__proposal_id__changestatus_leader_post","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"proposal_id","in":"path","required":true,"schema":{"type":"integer","title":"Proposal Id"}},{"name":"new_status","in":"query","required":true,"schema":{"type":"boolean","title":"New Status"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ProposalResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/proposals/{proposal_id}/changestatus/representative":{"post":{"tags":["proposals"],"summary":"Change Status By Representative","operationId":"change_status_by_representative_proposals__proposal_id__changestatus_representative_post","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"proposal_id","in":"path","required":true,"schema":{"type":"integer","title":"Proposal Id"}},{"name":"new_status","in":"query","required":true,"schema":{"type":"boolean","title":"New Status"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ProposalResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/change_requests/":{"get":{"tags":["change_requests"],"summary":"Get Requests","description":"Retrieve a paginated list of all change requests.\n\nArgs:\n    skip (int, optional): Number of records to skip. Defaults to 0.\n    limit (int, optional): Maximum number of records to return. Defaults to 10.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nReturns:\n    list[ChangeRequest]: List of change requests.","operationId":"get_requests_change_requests__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"skip","in":"query","required":false,"schema":{"type":"integer","default":0,"title":"Skip"}},{"name":"limit","in":"query","required":false,"schema":{"type":"integer","default":10,"title":"Limit"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ChangeRequestResponse"},"title":"Response Get Requests Change Requests  Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"post":{"tags":["change_requests"],"summary":"Create Request","description":"Create a new change request.\n\nArgs:\n    request (ChangeRequestCreate): Data for the new change request.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nRaises:\n    HTTPException: If course event or user is not found.\n\nReturns:\n    ChangeRequest: The newly created change request.","operationId":"create_request_change_requests__post","security":[{"OAuth2PasswordBearer":[]}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeRequestCreate"}}}},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeRequestResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/change_requests/related":{"get":{"tags":["change_requests"],"summary":"Get Related Requests","description":"Get all change requests related to the current user, optionally filtered by status,\nwith pagination.\nIncludes requests:\n- created by the user\n- for courses where the user is the teacher\n- for courses where the user is group leader (starosta)","operationId":"get_related_requests_change_requests_related_get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"status","in":"query","required":false,"schema":{"anyOf":[{"$ref":"#/components/schemas/ChangeRequestStatus"},{"type":"null"}],"description":"Optional status filter","title":"Status"},"description":"Optional status filter"},{"name":"skip","in":"query","required":false,"schema":{"type":"integer","default":0,"title":"Skip"}},{"name":"limit","in":"query","required":false,"schema":{"type":"integer","default":10,"title":"Limit"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ChangeRequestResponse"},"title":"Response Get Related Requests Change Requests Related Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/change_requests/{event_id}":{"get":{"tags":["change_requests"],"summary":"Get Request By Id","description":"Retrieve a specific change request by ID.\n\nArgs:\n    request_id (int): ID of the change request to retrieve.\n    db (Session): Database session.\n\nRaises:\n    HTTPException: If change request with the specified ID is not found.\n\nReturns:\n    ChangeRequest: The requested change request.","operationId":"get_request_by_id_change_requests__event_id__get","parameters":[{"name":"request_id","in":"query","required":true,"schema":{"type":"integer","title":"Request Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeRequestResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/change_requests/{request_id}":{"put":{"tags":["change_requests"],"summary":"Update Request","description":"Update an existing change request.\n\nArgs:\n    request (ChangeRequestUpdate): Updated change request data.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nRaises:\n    HTTPException: If change request, course event, or user is not found.\n\nReturns:\n    ChangeRequest: The updated change request.","operationId":"update_request_change_requests__request_id__put","security":[{"OAuth2PasswordBearer":[]}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeRequestUpdate"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeRequestResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["change_requests"],"summary":"Delete Request","description":"Delete a change request by ID.\n\nArgs:\n    request_id (int): ID of the change request to delete.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nRaises:\n    HTTPException: If change request with the specified ID is not found.","operationId":"delete_request_change_requests__request_id__delete","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"request_id","in":"path","required":true,"schema":{"type":"integer","title":"Request Id"}}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/courses/":{"get":{"tags":["courses"],"summary":"Get Courses","description":"Get all courses.\n\nArgs:\n    db (Session): Database session\n    current_user (User): Current authenticated user\n\nReturns:\n    list[Course]: List of all courses","operationId":"get_courses_courses__get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"items":{"$ref":"#/components/schemas/CourseResponse"},"type":"array","title":"Response Get Courses Courses  Get"}}}}},"security":[{"OAuth2PasswordBearer":[]}]},"post":{"tags":["courses"],"summary":"Create Course","description":"Create a new course.\n\nArgs:\n    course (CourseCreate): Course data for creation\n    db (Session): Database session\n    current_user (User): Current authenticated user (must be ADMIN, KOORDYNATOR or PROWADZACY)\n\nRaises:\n    HTTPException: If teacher or group is not found\n\nReturns:\n    Course: The created course","operationId":"create_course_courses__post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CourseCreate"}}},"required":true},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/CourseResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"security":[{"OAuth2PasswordBearer":[]}]}},"/courses/{course_id}":{"get":{"tags":["courses"],"summary":"Get Course","description":"Get a single course by ID.\n\nArgs:\n    course_id (int): ID of the course to retrieve\n    db (Session): Database session\n    current_user (User): Current authenticated user\n\nRaises:\n    HTTPException: If course is not found\n\nReturns:\n    Course: The requested course","operationId":"get_course_courses__course_id__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"course_id","in":"path","required":true,"schema":{"type":"integer","title":"Course Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/CourseResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["courses"],"summary":"Delete Course","description":"Delete a course by ID.\n\nArgs:\n    course_id (int): ID of the course to delete\n    db (Session): Database session\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR)\n\nRaises:\n    HTTPException: If course is not found","operationId":"delete_course_courses__course_id__delete","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"course_id","in":"path","required":true,"schema":{"type":"integer","title":"Course Id"}}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"put":{"tags":["courses"],"summary":"Update Course","description":"Update a course by ID.\n\nArgs:\n    course_id (int): ID of the course to update\n    course (CourseCreate): Updated course data\n    db (Session): Database session\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR)\n\nRaises:\n    HTTPException: If course, teacher, or group is not found\n\nReturns:\n    Course: The updated course","operationId":"update_course_courses__course_id__put","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"course_id","in":"path","required":true,"schema":{"type":"integer","title":"Course Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CourseCreate"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/CourseResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/courses/events":{"post":{"tags":["courses"],"summary":"Create Event","description":"Create a new course event (schedule a class).\n\nArgs:\n    event (CourseEventCreate): Event data for creation\n    db (Session): Database session\n    current_user (User): Current authenticated user (must be ADMIN, KOORDYNATOR or PROWADZACY)\n\nRaises:\n    HTTPException: If course, room, or time slot is not found, or if time slot is already taken\n\nReturns:\n    CourseEvent: The created course event","operationId":"create_event_courses_events_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CourseEventCreate"}}},"required":true},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/CourseEventResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"security":[{"OAuth2PasswordBearer":[]}]}},"/courses/events/{event_id}":{"put":{"tags":["courses"],"summary":"Update Event","description":"Update a course event by ID.\n\nArgs:\n    event_id (int): ID of the event to update\n    event (CourseEventUpdate): Updated event data\n    db (Session): Database session\n    current_user (User): Current authenticated user (must be ADMIN, KOORDYNATOR or PROWADZACY)\n\nRaises:\n    HTTPException: If event, course, room, or time slot is not found, or if time slot is already taken\n\nReturns:\n    CourseEvent: The updated course event","operationId":"update_event_courses_events__event_id__put","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"event_id","in":"path","required":true,"schema":{"type":"integer","title":"Event Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CourseEventUpdate"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/CourseEventResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/courses/{course_id}/events":{"get":{"tags":["courses"],"summary":"Get Events For Course","description":"Get all events for a specific course.\n\nArgs:\n    course_id (int): ID of the course\n    db (Session): Database session\n    current_user (User): Current authenticated user\n\nReturns:\n    list[CourseEvent]: List of events for the specified course","operationId":"get_events_for_course_courses__course_id__events_get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"course_id","in":"path","required":true,"schema":{"type":"integer","title":"Course Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/CourseEventResponse"},"title":"Response Get Events For Course Courses  Course Id  Events Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/courses/group/{group_id}/events":{"get":{"tags":["courses"],"summary":"Get Events For Group","description":"Get all events for a specific group.\n\nArgs:\n    group_id (int): ID of the group\n    db (Session): Database session\n    current_user (User): Current authenticated user\n\nReturns:\n    list[CourseEvent]: List of events for the specified group","operationId":"get_events_for_group_courses_group__group_id__events_get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"group_id","in":"path","required":true,"schema":{"type":"integer","title":"Group Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/CourseEventResponse"},"title":"Response Get Events For Group Courses Group  Group Id  Events Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/courses/events/{course_event_id}":{"get":{"tags":["courses"],"summary":"Get Course Event","description":"Get a single course event by ID.\n\nArgs:\n    course_event_id (int): ID of the course event\n    db (Session): Database session\n    current_user (User): Current authenticated user\n\nRaises:\n    HTTPException: If event is not found\n\nReturns:\n    CourseEvent: The requested course event","operationId":"get_course_event_courses_events__course_event_id__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"course_event_id","in":"path","required":true,"schema":{"type":"integer","title":"Course Event Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/CourseEventResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/change_recommendation/common-availability":{"post":{"tags":["change_recommendation"],"summary":"Find And Add Common Availability","description":"Find common availability between two users and generate room change recommendations.\n\nArgs:\n    user1_id (int): ID of the first user\n    user2_id (int): ID of the second user\n    change_request_id (int): ID of the change request\n    db (Session): Database session\n    current_user (User): Current authenticated user\n    \nRaises:\n    HTTPException: If change request is not found or no common availability/rooms found\n    \nReturns:\n    dict: Success message with the number of recommendations added","operationId":"find_and_add_common_availability_change_recommendation_common_availability_post","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"user1_id","in":"query","required":true,"schema":{"type":"integer","title":"User1 Id"}},{"name":"user2_id","in":"query","required":true,"schema":{"type":"integer","title":"User2 Id"}},{"name":"change_request_id","in":"query","required":true,"schema":{"type":"integer","title":"Change Request Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","additionalProperties":true,"title":"Response Find And Add Common Availability Change Recommendation Common Availability Post"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/change_recommendation/{change_request_id}/recommendations":{"get":{"tags":["change_recommendation"],"summary":"Get Proposals","description":"Get all recommendations for a specific change request.\n\nArgs:\n    change_request_id (int): ID of the change request\n    db (Session): Database session\n    current_user (User): Current authenticated user\n    \nRaises:\n    HTTPException: If change request is not found\n    \nReturns:\n    list[ChangeRecomendation]: List of change recommendations","operationId":"get_proposals_change_recommendation__change_request_id__recommendations_get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"change_request_id","in":"path","required":true,"schema":{"type":"integer","title":"Change Request Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ChangeRecomendationResponse"},"title":"Response Get Proposals Change Recommendation  Change Request Id  Recommendations Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["change_recommendation"],"summary":"Delete Recommendations","description":"Delete all recommendations for a specific change request.\n\nArgs:\n    change_request_id (int): ID of the change request\n    db (Session): Database session\n    current_user (User): Current authenticated user\n    \nRaises:\n    HTTPException: If change request is not found","operationId":"delete_recommendations_change_recommendation__change_request_id__recommendations_delete","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"change_request_id","in":"path","required":true,"schema":{"type":"integer","title":"Change Request Id"}}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/room-unavailability/":{"get":{"tags":["room-unavailability"],"summary":"Get Room Unavailability","description":"Retrieve a list of all room unavailability periods.\n\nArgs:\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nReturns:\n    list[RoomUnavailability]: List of all room unavailability periods.","operationId":"get_room_unavailability_room_unavailability__get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"items":{"$ref":"#/components/schemas/RoomUnavailabilityResponse"},"type":"array","title":"Response Get Room Unavailability Room Unavailability  Get"}}}}},"security":[{"OAuth2PasswordBearer":[]}]},"post":{"tags":["room-unavailability"],"summary":"Create Room Unavailability","description":"Create a new room unavailability period.\n\nArgs:\n    unavailability (RoomUnavailabilityCreate): Data for the new unavailability period.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If end time is not greater than start time, room is not found,\n                  or the period overlaps with existing unavailability.\n\nReturns:\n    RoomUnavailability: The newly created room unavailability period.","operationId":"create_room_unavailability_room_unavailability__post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/RoomUnavailabilityCreate"}}},"required":true},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/RoomUnavailabilityResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"security":[{"OAuth2PasswordBearer":[]}]}},"/room-unavailability/{unavailability_id}":{"get":{"tags":["room-unavailability"],"summary":"Get Room Unavailability By Id","description":"Retrieve a specific room unavailability period by ID.\n\nArgs:\n    unavailability_id (int): ID of the unavailability period to retrieve.\n    db (Session): Database session.\n    current_user (User): Current authenticated user.\n\nRaises:\n    HTTPException: If the unavailability period is not found.\n\nReturns:\n    RoomUnavailability: The requested room unavailability period.","operationId":"get_room_unavailability_by_id_room_unavailability__unavailability_id__get","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"unavailability_id","in":"path","required":true,"schema":{"type":"integer","title":"Unavailability Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/RoomUnavailabilityResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"put":{"tags":["room-unavailability"],"summary":"Update Room Unavailability","description":"Update an existing room unavailability period.\n\nArgs:\n    unavailability_id (int): ID of the unavailability period to update.\n    unavailability (RoomUnavailabilityUpdate): Updated unavailability data.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If the unavailability period is not found or end time is not greater than start time.\n\nReturns:\n    RoomUnavailability: The updated room unavailability period.","operationId":"update_room_unavailability_room_unavailability__unavailability_id__put","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"unavailability_id","in":"path","required":true,"schema":{"type":"integer","title":"Unavailability Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/RoomUnavailabilityUpdate"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/RoomUnavailabilityResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["room-unavailability"],"summary":"Delete Room Unavailability","description":"Delete a room unavailability period by ID.\n\nArgs:\n    unavailability_id (int): ID of the unavailability period to delete.\n    db (Session): Database session.\n    current_user (User): Current authenticated user (must be ADMIN or KOORDYNATOR).\n\nRaises:\n    HTTPException: If the unavailability period is not found.","operationId":"delete_room_unavailability_room_unavailability__unavailability_id__delete","security":[{"OAuth2PasswordBearer":[]}],"parameters":[{"name":"unavailability_id","in":"path","required":true,"schema":{"type":"integer","title":"Unavailability Id"}}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/equipment/":{"get":{"tags":["equipment"],"summary":"Get All Equipment","operationId":"get_all_equipment_equipment__get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"items":{"$ref":"#/components/schemas/EquipmentResponse"},"type":"array","title":"Response Get All Equipment Equipment  Get"}}}}}},"post":{"tags":["equipment"],"summary":"Add Equipment","operationId":"add_equipment_equipment__post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/EquipmentCreate"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/EquipmentResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/equipment/{equipment_id}":{"delete":{"tags":["equipment"],"summary":"Delete Equipment","operationId":"delete_equipment_equipment__equipment_id__delete","parameters":[{"name":"equipment_id","in":"path","required":true,"schema":{"type":"integer","title":"Equipment Id"}}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/":{"get":{"summary":"Root","operationId":"root__get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}}}}}},"components":{"schemas":{"AvailabilityProposalResponse":{"properties":{"id":{"type":"integer","title":"Id"},"user_id":{"type":"integer","title":"User Id"},"day":{"type":"string","format":"date","title":"Day"},"time_slot_id":{"type":"integer","title":"Time Slot Id"}},"type":"object","required":["id","user_id","day","time_slot_id"],"title":"AvailabilityProposalResponse"},"Body_login_for_access_token_auth_token_post":{"properties":{"grant_type":{"anyOf":[{"type":"string","pattern":"^password$"},{"type":"null"}],"title":"Grant Type"},"username":{"type":"string","title":"Username"},"password":{"type":"string","title":"Password"},"scope":{"type":"string","title":"Scope","default":""},"client_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Client Id"},"client_secret":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Client Secret"}},"type":"object","required":["username","password"],"title":"Body_login_for_access_token_auth_token_post"},"ChangeRecomendationResponse":{"properties":{"id":{"type":"integer","title":"Id"},"change_request_id":{"type":"integer","title":"Change Request Id"},"recommended_day":{"type":"string","format":"date","title":"Recommended Day"},"recommended_slot_id":{"type":"integer","title":"Recommended Slot Id"},"recommended_room_id":{"type":"integer","title":"Recommended Room Id"},"source_proposal":{"anyOf":[{"$ref":"#/components/schemas/AvailabilityProposalResponse"},{"type":"null"}]}},"type":"object","required":["id","change_request_id","recommended_day","recommended_slot_id","recommended_room_id"],"title":"ChangeRecomendationResponse"},"ChangeRequestCreate":{"properties":{"course_event_id":{"type":"integer","title":"Course Event Id"},"initiator_id":{"type":"integer","title":"Initiator Id"},"status":{"$ref":"#/components/schemas/ChangeRequestStatus"},"reason":{"type":"string","title":"Reason"},"room_requirements":{"type":"string","title":"Room Requirements"},"minimum_capacity":{"type":"integer","title":"Minimum Capacity"},"created_at":{"type":"string","format":"date-time","title":"Created At"}},"type":"object","required":["course_event_id","initiator_id","status","reason","room_requirements","minimum_capacity","created_at"],"title":"ChangeRequestCreate"},"ChangeRequestResponse":{"properties":{"id":{"type":"integer","title":"Id"},"course_event_id":{"type":"integer","title":"Course Event Id"},"initiator_id":{"type":"integer","title":"Initiator Id"},"status":{"$ref":"#/components/schemas/ChangeRequestStatus"},"reason":{"type":"string","title":"Reason"},"room_requirements":{"type":"string","title":"Room Requirements"},"minimum_capacity":{"type":"integer","title":"Minimum Capacity"},"created_at":{"type":"string","format":"date-time","title":"Created At"}},"type":"object","required":["id","course_event_id","initiator_id","status","reason","room_requirements","minimum_capacity","created_at"],"title":"ChangeRequestResponse"},"ChangeRequestStatus":{"type":"string","enum":["PENDING","ACCEPTED","REJECTED","CANCELLED"],"title":"ChangeRequestStatus"},"ChangeRequestUpdate":{"properties":{"change_request_id":{"type":"integer","title":"Change Request Id"},"course_event_id":{"type":"integer","title":"Course Event Id"},"initiator_id":{"type":"integer","title":"Initiator Id"},"status":{"anyOf":[{"$ref":"#/components/schemas/ChangeRequestStatus"},{"type":"null"}]},"reason":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Reason"},"room_requirements":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Room Requirements"},"minimum_capacity":{"type":"integer","title":"Minimum Capacity"},"created_at":{"type":"string","format":"date-time","title":"Created At"}},"type":"object","required":["change_request_id","course_event_id","initiator_id","status","reason","room_requirements","minimum_capacity","created_at"],"title":"ChangeRequestUpdate"},"CourseCreate":{"properties":{"name":{"type":"string","title":"Name"},"teacher_id":{"type":"integer","title":"Teacher Id"},"group_id":{"type":"integer","title":"Group Id"}},"type":"object","required":["name","teacher_id","group_id"],"title":"CourseCreate"},"CourseEventCreate":{"properties":{"course_id":{"type":"integer","title":"Course Id"},"room_id":{"type":"integer","title":"Room Id"},"day":{"type":"string","format":"date","title":"Day"},"time_slot_id":{"type":"integer","title":"Time Slot Id"},"canceled":{"type":"boolean","title":"Canceled","default":false}},"type":"object","required":["course_id","room_id","day","time_slot_id"],"title":"CourseEventCreate"},"CourseEventResponse":{"properties":{"course_id":{"type":"integer","title":"Course Id"},"room_id":{"type":"integer","title":"Room Id"},"day":{"type":"string","format":"date","title":"Day"},"time_slot_id":{"type":"integer","title":"Time Slot Id"},"canceled":{"type":"boolean","title":"Canceled","default":false},"id":{"type":"integer","title":"Id"}},"type":"object","required":["course_id","room_id","day","time_slot_id","id"],"title":"CourseEventResponse"},"CourseEventUpdate":{"properties":{"room_id":{"type":"integer","title":"Room Id"},"day":{"type":"string","format":"date","title":"Day"},"time_slot_id":{"type":"integer","title":"Time Slot Id"},"canceled":{"type":"boolean","title":"Canceled","default":false}},"type":"object","required":["room_id","day","time_slot_id"],"title":"CourseEventUpdate"},"CourseResponse":{"properties":{"name":{"type":"string","title":"Name"},"teacher_id":{"type":"integer","title":"Teacher Id"},"group_id":{"type":"integer","title":"Group Id"},"id":{"type":"integer","title":"Id"}},"type":"object","required":["name","teacher_id","group_id","id"],"title":"CourseResponse"},"EquipmentCreate":{"properties":{"name":{"type":"string","title":"Name"}},"type":"object","required":["name"],"title":"EquipmentCreate"},"EquipmentResponse":{"properties":{"name":{"type":"string","title":"Name"},"id":{"type":"integer","title":"Id"}},"type":"object","required":["name","id"],"title":"EquipmentResponse"},"GroupCreate":{"properties":{"name":{"type":"string","title":"Name"},"year":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Year"},"leader_id":{"type":"integer","title":"Leader Id"}},"type":"object","required":["name","year","leader_id"],"title":"GroupCreate"},"GroupResponse":{"properties":{"id":{"type":"integer","title":"Id"},"name":{"type":"string","title":"Name"},"year":{"type":"integer","title":"Year"},"leader_id":{"type":"integer","title":"Leader Id"}},"type":"object","required":["id","name","year","leader_id"],"title":"GroupResponse"},"GroupUpdate":{"properties":{"name":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Name"},"year":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Year"},"leader_id":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Leader Id"}},"type":"object","required":["name","year","leader_id"],"title":"GroupUpdate"},"HTTPValidationError":{"properties":{"detail":{"items":{"$ref":"#/components/schemas/ValidationError"},"type":"array","title":"Detail"}},"type":"object","title":"HTTPValidationError"},"ProposalCreate":{"properties":{"change_request_id":{"type":"integer","title":"Change Request Id"},"user_id":{"type":"integer","title":"User Id"},"day":{"type":"string","format":"date","title":"Day"},"time_slot_id":{"type":"integer","title":"Time Slot Id"}},"type":"object","required":["change_request_id","user_id","day","time_slot_id"],"title":"ProposalCreate"},"ProposalResponse":{"properties":{"id":{"type":"integer","title":"Id"},"change_request_id":{"type":"integer","title":"Change Request Id"},"accepted_by_leader":{"type":"boolean","title":"Accepted By Leader"},"accepted_by_representative":{"type":"boolean","title":"Accepted By Representative"},"user_id":{"type":"integer","title":"User Id"},"day":{"type":"string","format":"date","title":"Day"},"time_slot_id":{"type":"integer","title":"Time Slot Id"}},"type":"object","required":["id","change_request_id","accepted_by_leader","accepted_by_representative","user_id","day","time_slot_id"],"title":"ProposalResponse"},"ProposalUpdate":{"properties":{"user_id":{"type":"integer","title":"User Id"},"day":{"type":"string","format":"date","title":"Day"},"time_slot_id":{"type":"integer","title":"Time Slot Id"}},"type":"object","required":["user_id","day","time_slot_id"],"title":"ProposalUpdate"},"RoomCreate":{"properties":{"name":{"type":"string","title":"Name"},"capacity":{"type":"integer","title":"Capacity"},"type":{"$ref":"#/components/schemas/RoomType"},"equipment_ids":{"items":{"type":"integer"},"type":"array","title":"Equipment Ids","default":[]}},"type":"object","required":["name","capacity","type"],"title":"RoomCreate"},"RoomResponse":{"properties":{"id":{"type":"integer","title":"Id"},"name":{"type":"string","title":"Name"},"capacity":{"type":"integer","title":"Capacity"},"type":{"$ref":"#/components/schemas/RoomType"},"equipment":{"items":{"$ref":"#/components/schemas/EquipmentResponse"},"type":"array","title":"Equipment","default":[]}},"type":"object","required":["id","name","capacity","type"],"title":"RoomResponse"},"RoomType":{"type":"string","enum":["LECTURE_HALL","LABORATORY","SEMINAR_ROOM","CONFERENCE_ROOM","OTHER"],"title":"RoomType"},"RoomUnavailabilityCreate":{"properties":{"room_id":{"type":"integer","title":"Room Id"},"start_datetime":{"type":"string","format":"date","title":"Start Datetime"},"end_datetime":{"type":"string","format":"date","title":"End Datetime"}},"type":"object","required":["room_id","start_datetime","end_datetime"],"title":"RoomUnavailabilityCreate"},"RoomUnavailabilityResponse":{"properties":{"id":{"type":"integer","title":"Id"},"room_id":{"type":"integer","title":"Room Id"},"start_datetime":{"type":"string","format":"date","title":"Start Datetime"},"end_datetime":{"type":"string","format":"date","title":"End Datetime"}},"type":"object","required":["id","room_id","start_datetime","end_datetime"],"title":"RoomUnavailabilityResponse"},"RoomUnavailabilityUpdate":{"properties":{"start_datetime":{"type":"string","format":"date","title":"Start Datetime"},"end_datetime":{"type":"string","format":"date","title":"End Datetime"}},"type":"object","required":["start_datetime","end_datetime"],"title":"RoomUnavailabilityUpdate"},"RoomUpdate":{"properties":{"capacity":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Capacity"},"type":{"anyOf":[{"$ref":"#/components/schemas/RoomType"},{"type":"null"}]},"equipment_ids":{"anyOf":[{"items":{"type":"integer"},"type":"array"},{"type":"null"}],"title":"Equipment Ids"}},"type":"object","required":["capacity","type"],"title":"RoomUpdate"},"Token":{"properties":{"access_token":{"type":"string","title":"Access Token"},"token_type":{"type":"string","title":"Token Type"}},"type":"object","required":["access_token","token_type"],"title":"Token"},"UserCreate":{"properties":{"name":{"type":"string","title":"Name"},"surname":{"type":"string","title":"Surname"},"email":{"type":"string","format":"email","title":"Email"},"password":{"type":"string","title":"Password"},"role":{"$ref":"#/components/schemas/UserRole"}},"type":"object","required":["name","surname","email","password","role"],"title":"UserCreate"},"UserResponse":{"properties":{"id":{"type":"integer","title":"Id"},"name":{"type":"string","title":"Name"},"surname":{"type":"string","title":"Surname"},"email":{"type":"string","title":"Email"},"role":{"$ref":"#/components/schemas/UserRole"}},"type":"object","required":["id","name","surname","email","role"],"title":"UserResponse"},"UserRole":{"type":"string","enum":["ADMIN","KOORDYNATOR","PROWADZACY","STAROSTA"],"title":"UserRole"},"ValidationError":{"properties":{"loc":{"items":{"anyOf":[{"type":"string"},{"type":"integer"}]},"type":"array","title":"Location"},"msg":{"type":"string","title":"Message"},"type":{"type":"string","title":"Error Type"}},"type":"object","required":["loc","msg","type"],"title":"ValidationError"}},"securitySchemes":{"OAuth2PasswordBearer":{"type":"oauth2","flows":{"password":{"scopes":{},"tokenUrl":"auth/token"}}}}}}
